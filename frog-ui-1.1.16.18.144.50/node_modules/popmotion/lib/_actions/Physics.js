'use strict';

exports.__esModule = true;

var _Action2 = require('./Action');

var _Action3 = _interopRequireDefault(_Action2);

var _calc = require('../inc/calc');

var _utils = require('../inc/utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Physics = function (_Action) {
  _inherits(Physics, _Action);

  function Physics() {
    _classCallCheck(this, Physics);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = _possibleConstructorReturn(this, _Action.call.apply(_Action, [this].concat(args)));

    _this.inactiveFrames = 0;
    _this.calculatesVelocity = true;
    return _this;
  }

  Physics.prototype.onUpdate = function onUpdate(physics, frameStamp, elapsed) {
    this.hasChanged = false;

    for (var i = 0; i < this.numValueKeys; i++) {
      var key = this.valueKeys[i];
      var value = this.values[key];
      var previousValue = value.prev;

      // Apply acceleration
      value.velocity += (0, _calc.speedPerFrame)(value.acceleration, elapsed);

      // Apply friction
      value.velocity *= Math.pow(1 - value.friction, elapsed / 100);

      // Apply spring
      if (value.spring && (0, _utils.isNum)(value.to)) {
        var distanceToTarget = value.to - value.current;
        value.velocity += distanceToTarget * (0, _calc.speedPerFrame)(value.spring, elapsed);
      }

      // Apply latest velocity
      value.current += (0, _calc.speedPerFrame)(value.velocity, elapsed);

      // Detect bounce
      if (value.min !== undefined && value.current < value.min || value.max !== undefined && value.current > value.max) {
        value.velocity *= -value.bounce;
      }

      // Check if value has changed
      if (value.current !== previousValue || Math.abs(value.velocity) >= value.stopSpeed || value.spring && value.current !== value.to) {
        this.hasChanged = true;
      }
    }
  };

  Physics.prototype.onFrameEnd = function onFrameEnd() {
    if (this.maxInactiveFrames !== Infinity) {
      this.inactiveFrames = this.hasChanged ? 1 : this.inactiveFrames + 1;

      if (this.inactiveFrames >= this.maxInactiveFrames) {
        this.complete();
      }
    }
  };

  return Physics;
}(_Action3.default);

Physics.prototype.defaultValueProp = 'velocity';
Physics.prototype.defaultValue = _Action3.default.extendDefaultValue({
  acceleration: 0, // [number]: Acceleration to apply to value, in units per second
  bounce: 0, // [number]: Factor to multiply velocity by on bounce
  spring: 0, // [number]: Spring strength during 'string'
  stopSpeed: 0.001, // [number]: Stop simulation under this speed
  friction: 0 // [number]: Friction to apply per frame, 0-1
});
Physics.prototype.defaultProps = _Action3.default.extendDefaultProps({
  maxInactiveFrames: 3
});

exports.default = Physics;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9fYWN0aW9ucy9QaHlzaWNzLmpzIl0sIm5hbWVzIjpbIlBoeXNpY3MiLCJhcmdzIiwiaW5hY3RpdmVGcmFtZXMiLCJjYWxjdWxhdGVzVmVsb2NpdHkiLCJvblVwZGF0ZSIsInBoeXNpY3MiLCJmcmFtZVN0YW1wIiwiZWxhcHNlZCIsImhhc0NoYW5nZWQiLCJpIiwibnVtVmFsdWVLZXlzIiwia2V5IiwidmFsdWVLZXlzIiwidmFsdWUiLCJ2YWx1ZXMiLCJwcmV2aW91c1ZhbHVlIiwicHJldiIsInZlbG9jaXR5IiwiYWNjZWxlcmF0aW9uIiwiZnJpY3Rpb24iLCJzcHJpbmciLCJ0byIsImRpc3RhbmNlVG9UYXJnZXQiLCJjdXJyZW50IiwibWluIiwidW5kZWZpbmVkIiwibWF4IiwiYm91bmNlIiwiTWF0aCIsImFicyIsInN0b3BTcGVlZCIsIm9uRnJhbWVFbmQiLCJtYXhJbmFjdGl2ZUZyYW1lcyIsIkluZmluaXR5IiwiY29tcGxldGUiLCJwcm90b3R5cGUiLCJkZWZhdWx0VmFsdWVQcm9wIiwiZGVmYXVsdFZhbHVlIiwiZXh0ZW5kRGVmYXVsdFZhbHVlIiwiZGVmYXVsdFByb3BzIiwiZXh0ZW5kRGVmYXVsdFByb3BzIl0sIm1hcHBpbmdzIjoiOzs7O0FBQUE7Ozs7QUFDQTs7QUFDQTs7Ozs7Ozs7OztJQUVNQSxPO1lBQUFBLE87O0FBQ0osV0FESUEsT0FDSixHQUFxQjtBQUFBLDBCQURqQkEsT0FDaUI7O0FBQUEsc0NBQU5DLElBQU07QUFBTkEsVUFBTTtBQUFBOztBQUFBLGlEQUNuQiwwQ0FBU0EsSUFBVCxFQURtQjs7QUFFbkIsVUFBS0MsY0FBTCxHQUFzQixDQUF0QjtBQUNBLFVBQUtDLGtCQUFMLEdBQTBCLElBQTFCO0FBSG1CO0FBSXBCOztBQUxHSCxTLFdBT0pJLFEscUJBQVNDLE8sRUFBU0MsVSxFQUFZQyxPLEVBQVM7QUFDckMsU0FBS0MsVUFBTCxHQUFrQixLQUFsQjs7QUFFQSxTQUFLLElBQUlDLElBQUksQ0FBYixFQUFnQkEsSUFBSSxLQUFLQyxZQUF6QixFQUF1Q0QsR0FBdkMsRUFBNEM7QUFDMUMsVUFBTUUsTUFBTSxLQUFLQyxTQUFMLENBQWVILENBQWYsQ0FBWjtBQUNBLFVBQU1JLFFBQVEsS0FBS0MsTUFBTCxDQUFZSCxHQUFaLENBQWQ7QUFDQSxVQUFNSSxnQkFBZ0JGLE1BQU1HLElBQTVCOztBQUVBO0FBQ0FILFlBQU1JLFFBQU4sSUFBa0IseUJBQWNKLE1BQU1LLFlBQXBCLEVBQWtDWCxPQUFsQyxDQUFsQjs7QUFFQTtBQUNBTSxZQUFNSSxRQUFOLGFBQW1CLElBQUlKLE1BQU1NLFFBQTdCLEVBQTJDWixVQUFVLEdBQXJEOztBQUVBO0FBQ0EsVUFBSU0sTUFBTU8sTUFBTixJQUFnQixrQkFBTVAsTUFBTVEsRUFBWixDQUFwQixFQUFxQztBQUNuQyxZQUFNQyxtQkFBbUJULE1BQU1RLEVBQU4sR0FBV1IsTUFBTVUsT0FBMUM7QUFDQVYsY0FBTUksUUFBTixJQUFrQkssbUJBQW1CLHlCQUFjVCxNQUFNTyxNQUFwQixFQUE0QmIsT0FBNUIsQ0FBckM7QUFDRDs7QUFFRDtBQUNBTSxZQUFNVSxPQUFOLElBQWlCLHlCQUFjVixNQUFNSSxRQUFwQixFQUE4QlYsT0FBOUIsQ0FBakI7O0FBRUE7QUFDQSxVQUFLTSxNQUFNVyxHQUFOLEtBQWNDLFNBQWQsSUFBMkJaLE1BQU1VLE9BQU4sR0FBZ0JWLE1BQU1XLEdBQWxELElBQTJEWCxNQUFNYSxHQUFOLEtBQWNELFNBQWQsSUFBMkJaLE1BQU1VLE9BQU4sR0FBZ0JWLE1BQU1hLEdBQWhILEVBQXNIO0FBQ3BIYixjQUFNSSxRQUFOLElBQWtCLENBQUVKLE1BQU1jLE1BQTFCO0FBQ0Q7O0FBRUQ7QUFDQSxVQUFJZCxNQUFNVSxPQUFOLEtBQWtCUixhQUFsQixJQUFtQ2EsS0FBS0MsR0FBTCxDQUFTaEIsTUFBTUksUUFBZixLQUE0QkosTUFBTWlCLFNBQXJFLElBQW1GakIsTUFBTU8sTUFBTixJQUFnQlAsTUFBTVUsT0FBTixLQUFrQlYsTUFBTVEsRUFBL0gsRUFBb0k7QUFDbEksYUFBS2IsVUFBTCxHQUFrQixJQUFsQjtBQUNEO0FBQ0Y7QUFDRixHOztBQXhDR1IsUyxXQTBDSitCLFUseUJBQWE7QUFDWCxRQUFJLEtBQUtDLGlCQUFMLEtBQTJCQyxRQUEvQixFQUF5QztBQUN2QyxXQUFLL0IsY0FBTCxHQUFzQixLQUFLTSxVQUFMLEdBQWtCLENBQWxCLEdBQXNCLEtBQUtOLGNBQUwsR0FBc0IsQ0FBbEU7O0FBRUEsVUFBSSxLQUFLQSxjQUFMLElBQXVCLEtBQUs4QixpQkFBaEMsRUFBbUQ7QUFDakQsYUFBS0UsUUFBTDtBQUNEO0FBQ0Y7QUFDRixHOztTQWxER2xDLE87OztBQXFETkEsUUFBUW1DLFNBQVIsQ0FBa0JDLGdCQUFsQixHQUFxQyxVQUFyQztBQUNBcEMsUUFBUW1DLFNBQVIsQ0FBa0JFLFlBQWxCLEdBQWlDLGlCQUFPQyxrQkFBUCxDQUEwQjtBQUN6RHBCLGdCQUFjLENBRDJDLEVBQ3hDO0FBQ2pCUyxVQUFRLENBRmlELEVBRTlDO0FBQ1hQLFVBQVEsQ0FIaUQsRUFHOUM7QUFDWFUsYUFBVyxLQUo4QyxFQUl2QztBQUNsQlgsWUFBVSxDQUwrQyxDQUs3QztBQUw2QyxDQUExQixDQUFqQztBQU9BbkIsUUFBUW1DLFNBQVIsQ0FBa0JJLFlBQWxCLEdBQWlDLGlCQUFPQyxrQkFBUCxDQUEwQjtBQUN6RFIscUJBQW1CO0FBRHNDLENBQTFCLENBQWpDOztrQkFJZWhDLE8iLCJmaWxlIjoiUGh5c2ljcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBBY3Rpb24gZnJvbSAnLi9BY3Rpb24nO1xuaW1wb3J0IHsgc3BlZWRQZXJGcmFtZSB9IGZyb20gJy4uL2luYy9jYWxjJztcbmltcG9ydCB7IGlzTnVtIH0gZnJvbSAnLi4vaW5jL3V0aWxzJztcblxuY2xhc3MgUGh5c2ljcyBleHRlbmRzIEFjdGlvbiB7XG4gIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKTtcbiAgICB0aGlzLmluYWN0aXZlRnJhbWVzID0gMDtcbiAgICB0aGlzLmNhbGN1bGF0ZXNWZWxvY2l0eSA9IHRydWU7XG4gIH1cblxuICBvblVwZGF0ZShwaHlzaWNzLCBmcmFtZVN0YW1wLCBlbGFwc2VkKSB7XG4gICAgdGhpcy5oYXNDaGFuZ2VkID0gZmFsc2U7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubnVtVmFsdWVLZXlzOyBpKyspIHtcbiAgICAgIGNvbnN0IGtleSA9IHRoaXMudmFsdWVLZXlzW2ldO1xuICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLnZhbHVlc1trZXldO1xuICAgICAgY29uc3QgcHJldmlvdXNWYWx1ZSA9IHZhbHVlLnByZXY7XG5cbiAgICAgIC8vIEFwcGx5IGFjY2VsZXJhdGlvblxuICAgICAgdmFsdWUudmVsb2NpdHkgKz0gc3BlZWRQZXJGcmFtZSh2YWx1ZS5hY2NlbGVyYXRpb24sIGVsYXBzZWQpO1xuXG4gICAgICAvLyBBcHBseSBmcmljdGlvblxuICAgICAgdmFsdWUudmVsb2NpdHkgKj0gKDEgLSB2YWx1ZS5mcmljdGlvbikgKiogKGVsYXBzZWQgLyAxMDApO1xuXG4gICAgICAvLyBBcHBseSBzcHJpbmdcbiAgICAgIGlmICh2YWx1ZS5zcHJpbmcgJiYgaXNOdW0odmFsdWUudG8pKSB7XG4gICAgICAgIGNvbnN0IGRpc3RhbmNlVG9UYXJnZXQgPSB2YWx1ZS50byAtIHZhbHVlLmN1cnJlbnQ7XG4gICAgICAgIHZhbHVlLnZlbG9jaXR5ICs9IGRpc3RhbmNlVG9UYXJnZXQgKiBzcGVlZFBlckZyYW1lKHZhbHVlLnNwcmluZywgZWxhcHNlZCk7XG4gICAgICB9XG5cbiAgICAgIC8vIEFwcGx5IGxhdGVzdCB2ZWxvY2l0eVxuICAgICAgdmFsdWUuY3VycmVudCArPSBzcGVlZFBlckZyYW1lKHZhbHVlLnZlbG9jaXR5LCBlbGFwc2VkKTtcblxuICAgICAgLy8gRGV0ZWN0IGJvdW5jZVxuICAgICAgaWYgKCh2YWx1ZS5taW4gIT09IHVuZGVmaW5lZCAmJiB2YWx1ZS5jdXJyZW50IDwgdmFsdWUubWluKSB8fCAodmFsdWUubWF4ICE9PSB1bmRlZmluZWQgJiYgdmFsdWUuY3VycmVudCA+IHZhbHVlLm1heCkpIHtcbiAgICAgICAgdmFsdWUudmVsb2NpdHkgKj0gLSB2YWx1ZS5ib3VuY2U7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGlmIHZhbHVlIGhhcyBjaGFuZ2VkXG4gICAgICBpZiAodmFsdWUuY3VycmVudCAhPT0gcHJldmlvdXNWYWx1ZSB8fCBNYXRoLmFicyh2YWx1ZS52ZWxvY2l0eSkgPj0gdmFsdWUuc3RvcFNwZWVkIHx8ICh2YWx1ZS5zcHJpbmcgJiYgdmFsdWUuY3VycmVudCAhPT0gdmFsdWUudG8pKSB7XG4gICAgICAgIHRoaXMuaGFzQ2hhbmdlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgb25GcmFtZUVuZCgpIHtcbiAgICBpZiAodGhpcy5tYXhJbmFjdGl2ZUZyYW1lcyAhPT0gSW5maW5pdHkpIHtcbiAgICAgIHRoaXMuaW5hY3RpdmVGcmFtZXMgPSB0aGlzLmhhc0NoYW5nZWQgPyAxIDogdGhpcy5pbmFjdGl2ZUZyYW1lcyArIDE7XG5cbiAgICAgIGlmICh0aGlzLmluYWN0aXZlRnJhbWVzID49IHRoaXMubWF4SW5hY3RpdmVGcmFtZXMpIHtcbiAgICAgICAgdGhpcy5jb21wbGV0ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5QaHlzaWNzLnByb3RvdHlwZS5kZWZhdWx0VmFsdWVQcm9wID0gJ3ZlbG9jaXR5JztcblBoeXNpY3MucHJvdG90eXBlLmRlZmF1bHRWYWx1ZSA9IEFjdGlvbi5leHRlbmREZWZhdWx0VmFsdWUoe1xuICBhY2NlbGVyYXRpb246IDAsIC8vIFtudW1iZXJdOiBBY2NlbGVyYXRpb24gdG8gYXBwbHkgdG8gdmFsdWUsIGluIHVuaXRzIHBlciBzZWNvbmRcbiAgYm91bmNlOiAwLCAvLyBbbnVtYmVyXTogRmFjdG9yIHRvIG11bHRpcGx5IHZlbG9jaXR5IGJ5IG9uIGJvdW5jZVxuICBzcHJpbmc6IDAsIC8vIFtudW1iZXJdOiBTcHJpbmcgc3RyZW5ndGggZHVyaW5nICdzdHJpbmcnXG4gIHN0b3BTcGVlZDogMC4wMDEsIC8vIFtudW1iZXJdOiBTdG9wIHNpbXVsYXRpb24gdW5kZXIgdGhpcyBzcGVlZFxuICBmcmljdGlvbjogMCAvLyBbbnVtYmVyXTogRnJpY3Rpb24gdG8gYXBwbHkgcGVyIGZyYW1lLCAwLTFcbn0pO1xuUGh5c2ljcy5wcm90b3R5cGUuZGVmYXVsdFByb3BzID0gQWN0aW9uLmV4dGVuZERlZmF1bHRQcm9wcyh7XG4gIG1heEluYWN0aXZlRnJhbWVzOiAzXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgUGh5c2ljcztcbiJdfQ==