'use strict';

exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _Task2 = require('../task/Task');

var _Task3 = _interopRequireDefault(_Task2);

var _calc = require('../inc/calc');

var _utils = require('../inc/utils');

var _detect = require('../value-types/detect');

var _detect2 = _interopRequireDefault(_detect);

var _numericalValues = require('../inc/numerical-values');

var _numericalValues2 = _interopRequireDefault(_numericalValues);

var _detectAdapter = require('../inc/detect-adapter');

var _detectAdapter2 = _interopRequireDefault(_detectAdapter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var NUM_NUMERICAL_VALUES = _numericalValues2.default.length;

var defaultRenderer = function (_ref) {
  var state = _ref.state;
  var adapter = _ref.adapter;
  var adapterData = _ref.adapterData;
  var element = _ref.element;
  return adapter(element, state, adapterData);
};

var convertIfShouldBeNumber = function (value) {
  return !isNaN(value) ? parseFloat(value) : value;
};

var Action = function (_Task) {
  _inherits(Action, _Task);

  function Action() {
    var props = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, Action);

    props.state = {};
    props.valueKeys = [];
    props.parentKeys = [];
    return _possibleConstructorReturn(this, _Task.call(this, props));
  }

  /*
    # Set Action properties
    ## Set user-defined Action properties
     @param [object]
    @return [Action]
  */


  Action.prototype.set = function set() {
    var props = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    this.values = this.values || {};

    var values = props.values;

    var propsToSet = _objectWithoutProperties(props, ['values']);

    var inheritable = {};

    // Set non-consumed properties
    _Task.prototype.set.call(this, propsToSet);

    // Detect correct `adapter` if none exists and `element` is being set
    if (this.element) {
      if (!this.adapter) {
        // Ducktypish check for Adapter
        this.adapter = (0, _detectAdapter2.default)(this.element);

        if (this.adapter.getElementData) {
          this.adapterData = this.adapter.getElementData(this.element);
        }
      }

      if (!this.onRender) {
        this.onRender = defaultRenderer;
      }
    }

    // Prime an object to inherit from, with only `value` properties
    for (var key in this.defaultValue) {
      if (this.defaultValue.hasOwnProperty(key)) {
        if (propsToSet.hasOwnProperty(key)) {
          inheritable[key] = propsToSet[key];
        } else if (this[key] !== undefined) {
          inheritable[key] = this[key];
        }
      }
    }

    // Update existing values with inheritable properties
    for (var _key in this.values) {
      if (this.values.hasOwnProperty(_key)) {
        this.values[_key] = _extends({}, this.values[_key], inheritable);
      }
    }

    // Update
    if (values) {
      this.setValues(values, inheritable);

      // Precompute number of value key and parent keys to avoid per-frame measurement
      this.numValueKeys = this.valueKeys.length;
      this.numParentKeys = this.parentKeys.length;
    }

    return this;
  };

  Action.prototype.setValues = function setValues(values, inherit) {
    // Iterate over all incoming values and set
    for (var key in values) {
      if (values.hasOwnProperty(key)) {
        var hasChildren = false;
        var children = {};

        // Merge into existing value or create new
        var valueAlreadyExists = this.values[key] !== undefined;
        var newValue = valueAlreadyExists ? _extends({}, this.values[key]) : _extends({}, inherit);

        // If values is not an object, assign value to default prop
        if (!(0, _utils.isObj)(values[key])) {
          newValue[this.defaultValueProp] = values[key];
        } else {
          newValue = _extends({}, newValue, values[key]);
        }

        // If we've got an adapter, get the current value
        if (newValue.current === undefined && this.adapter) {
          newValue.current = convertIfShouldBeNumber(this.adapter.get(this.element, key));
        }

        if (newValue.from === undefined && this.adapter) {
          newValue.from = newValue.current;
        }

        // Apply default value properties
        if (!valueAlreadyExists) {
          newValue = _extends({}, this.defaultValue, newValue);
        }

        // If we don't have a value type and we do have an Adapter, check for type with value key
        if (!newValue.type && this.adapter && this.adapter.checkValueType) {
          newValue.type = this.adapter.checkValueType(key);
        }

        // If we still don't have a value type and this is the first time we've set this value, check numerical values for strings and test
        if (!newValue.type && !this.values[key]) {
          newValue.type = (0, _detect2.default)(newValue);
        }

        // If we have a value type, handle. This is my least favourite part of Popmotion, so... enjoy.
        if (newValue.type) {
          for (var i = 0; i < NUM_NUMERICAL_VALUES; i++) {
            var propName = _numericalValues2.default[i];
            var valueProp = newValue[propName];

            // If this prop is a string and we have a splitter, split
            if (newValue.type.hasOwnProperty('split')) {
              var splitProp = (0, _utils.isString)(valueProp) ? newValue.type.split(valueProp) : {};

              for (var splitKey in splitProp) {
                if (splitProp.hasOwnProperty(splitKey)) {
                  var combinedKey = key + splitKey;

                  // If we don't have a child value for this key, make one
                  if (!children[combinedKey]) {
                    var defaultValue = newValue.type.defaultProps && newValue.type.defaultProps[splitKey] ? newValue.type.defaultProps[splitKey] : newValue.type.defaultProps || {};

                    children[combinedKey] = _extends({}, newValue, defaultValue, {
                      parent: key,
                      childKey: splitKey
                    });

                    delete children[combinedKey].type;
                  }

                  hasChildren = true;
                  children[combinedKey][propName] = parseFloat(splitProp[splitKey]);
                }
              }

              // If we have a template function, generate
              if (!newValue.template && newValue.type.template && (0, _utils.isString)(valueProp)) {
                newValue.template = newValue.type.template(valueProp);
              }
            } else if (newValue.type.defaultProps) {
              newValue = _extends({}, newValue, newValue.type.defaultProps);
            }

            if (valueProp !== undefined && newValue.type.parse) {
              newValue[propName] = newValue.type.parse(valueProp, newValue);
            }
          }
        } // End value type nonsense

        // Set `prev` to `current` for first frame after set
        newValue.prev = newValue.current;

        // If this value doesn't have children, add to valueKeys
        if (!hasChildren) {
          if (this.valueKeys.indexOf(key) === -1) {
            this.valueKeys.push(key);
          }

          // Or add to parentKeys
        } else {
          newValue.children = newValue.children || {};

          if (this.parentKeys.indexOf(key) === -1) {
            this.parentKeys.push(key);
          }

          this.setValues(children);
        }

        this.values[key] = newValue;
      }
    }
  };

  /*
    Decide whether this Action will render on next frame
     @param [Action]
    @param [number]
    @param [number]
    @return [boolean]: Return true to render
  */


  Action.prototype.willRender = function willRender(action, frameStamp, elapsed) {
    var hasChanged = false;

    // Check if base values have updated 
    for (var i = 0; i < this.numValueKeys; i++) {
      var key = this.valueKeys[i];
      var value = this.values[key];

      // Run transform function (if present)
      if (value.transform) {
        value.current = value.transform(value.current, key, this);
      }

      // Cap minimum
      if ((0, _utils.isNum)(value.min)) {
        value.current = Math.max(value.current, value.min);
      }

      // Cap maximum
      if ((0, _utils.isNum)(value.max)) {
        value.current = Math.min(value.current, value.max);
      }

      // Round number
      if (value.round) {
        value.current = Math.round(value.current);
      }

      value.frameChange = value.current - value.prev;

      // Update velocity
      if (!this.calculatesVelocity) {
        value.velocity = (0, _calc.speedPerSecond)(value.frameChange, elapsed);
      }

      // If this value has changed
      if (value.prev !== value.current) {
        hasChanged = true;
        value.prev = value.current;
      }

      // Append unit
      var valueForState = value.type && value.type.serialize ? value.type.serialize(value.current, value) : value.current;

      // Add to state if this is not a child vaue
      if (!value.parent) {
        this.state[key] = valueForState;
      } else {
        this.values[value.parent].children[value.childKey] = valueForState;
      }
    }

    // Update parent values
    for (var _i = 0; _i < this.numParentKeys; _i++) {
      var _key2 = this.parentKeys[_i];
      var _value = this.values[_key2];

      _value.current = _value.type.combine(_value.children, _value.template);

      this.state[_key2] = _value.current;
    }

    if (this.onFrame) {
      this.onFrame(this.state, this);
    }

    return this.onCleanup ? true : hasChanged;
  };

  Action.prototype.inherit = function inherit() {
    var props = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
    var values = props.values;

    var propsToSet = _objectWithoutProperties(props, ['values']);

    var newAction = _Task.prototype.inherit.call(this, propsToSet);

    if (values) {
      newAction.set({ values: values });
    }

    return newAction;
  };

  Action.prototype.pause = function pause() {
    _Task.prototype.stop.call(this);
    return this;
  };

  Action.prototype.resume = function resume() {
    _Task.prototype.start.call(this);
    return this;
  };

  Action.prototype.toggle = function toggle() {
    return this.isActive ? this.pause() : this.resume();
  };

  Action.prototype.start = function start() {
    var values = this.values;
    _Task.prototype.start.call(this);

    for (var key in values) {
      if (values.hasOwnProperty(key)) {
        values[key].prev = values[key].origin = values[key].current;
      }
    }

    return this;
  };

  Action.extendDefaultValue = function extendDefaultValue(props) {
    return _extends({}, this.prototype.defaultValue, props);
  };

  Action.extendDefaultProps = function extendDefaultProps(props) {
    return _extends({}, this.prototype.defaultProps, props);
  };

  return Action;
}(_Task3.default);

Action.prototype.defaultValueProp = 'current';
Action.prototype.defaultValue = {
  current: 0,
  velocity: 0,
  round: false,
  min: undefined,
  max: undefined,
  transform: undefined
};

exports.default = Action;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9fYWN0aW9ucy9BY3Rpb24uanMiXSwibmFtZXMiOlsiTlVNX05VTUVSSUNBTF9WQUxVRVMiLCJsZW5ndGgiLCJkZWZhdWx0UmVuZGVyZXIiLCJzdGF0ZSIsImFkYXB0ZXIiLCJhZGFwdGVyRGF0YSIsImVsZW1lbnQiLCJjb252ZXJ0SWZTaG91bGRCZU51bWJlciIsInZhbHVlIiwiaXNOYU4iLCJwYXJzZUZsb2F0IiwiQWN0aW9uIiwicHJvcHMiLCJ2YWx1ZUtleXMiLCJwYXJlbnRLZXlzIiwic2V0IiwidmFsdWVzIiwicHJvcHNUb1NldCIsImluaGVyaXRhYmxlIiwiZ2V0RWxlbWVudERhdGEiLCJvblJlbmRlciIsImtleSIsImRlZmF1bHRWYWx1ZSIsImhhc093blByb3BlcnR5IiwidW5kZWZpbmVkIiwic2V0VmFsdWVzIiwibnVtVmFsdWVLZXlzIiwibnVtUGFyZW50S2V5cyIsImluaGVyaXQiLCJoYXNDaGlsZHJlbiIsImNoaWxkcmVuIiwidmFsdWVBbHJlYWR5RXhpc3RzIiwibmV3VmFsdWUiLCJkZWZhdWx0VmFsdWVQcm9wIiwiY3VycmVudCIsImdldCIsImZyb20iLCJ0eXBlIiwiY2hlY2tWYWx1ZVR5cGUiLCJpIiwicHJvcE5hbWUiLCJ2YWx1ZVByb3AiLCJzcGxpdFByb3AiLCJzcGxpdCIsInNwbGl0S2V5IiwiY29tYmluZWRLZXkiLCJkZWZhdWx0UHJvcHMiLCJwYXJlbnQiLCJjaGlsZEtleSIsInRlbXBsYXRlIiwicGFyc2UiLCJwcmV2IiwiaW5kZXhPZiIsInB1c2giLCJ3aWxsUmVuZGVyIiwiYWN0aW9uIiwiZnJhbWVTdGFtcCIsImVsYXBzZWQiLCJoYXNDaGFuZ2VkIiwidHJhbnNmb3JtIiwibWluIiwiTWF0aCIsIm1heCIsInJvdW5kIiwiZnJhbWVDaGFuZ2UiLCJjYWxjdWxhdGVzVmVsb2NpdHkiLCJ2ZWxvY2l0eSIsInZhbHVlRm9yU3RhdGUiLCJzZXJpYWxpemUiLCJjb21iaW5lIiwib25GcmFtZSIsIm9uQ2xlYW51cCIsIm5ld0FjdGlvbiIsInBhdXNlIiwic3RvcCIsInJlc3VtZSIsInN0YXJ0IiwidG9nZ2xlIiwiaXNBY3RpdmUiLCJvcmlnaW4iLCJleHRlbmREZWZhdWx0VmFsdWUiLCJwcm90b3R5cGUiLCJleHRlbmREZWZhdWx0UHJvcHMiXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOzs7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7Ozs7Ozs7OztBQUVBLElBQU1BLHVCQUF1QiwwQkFBaUJDLE1BQTlDOztBQUVBLElBQU1DLGtCQUFrQjtBQUFBLE1BQUdDLEtBQUgsUUFBR0EsS0FBSDtBQUFBLE1BQVVDLE9BQVYsUUFBVUEsT0FBVjtBQUFBLE1BQW1CQyxXQUFuQixRQUFtQkEsV0FBbkI7QUFBQSxNQUFnQ0MsT0FBaEMsUUFBZ0NBLE9BQWhDO0FBQUEsU0FBOENGLFFBQVFFLE9BQVIsRUFBaUJILEtBQWpCLEVBQXdCRSxXQUF4QixDQUE5QztBQUFBLENBQXhCOztBQUVBLElBQU1FLDBCQUEwQixVQUFDQyxLQUFEO0FBQUEsU0FBVyxDQUFDQyxNQUFNRCxLQUFOLENBQUQsR0FBZ0JFLFdBQVdGLEtBQVgsQ0FBaEIsR0FBb0NBLEtBQS9DO0FBQUEsQ0FBaEM7O0lBRU1HLE07WUFBQUEsTTs7QUFDSixXQURJQSxNQUNKLEdBQXdCO0FBQUEsUUFBWkMsS0FBWSx5REFBSixFQUFJOztBQUFBLDBCQURwQkQsTUFDb0I7O0FBQ3RCQyxVQUFNVCxLQUFOLEdBQWMsRUFBZDtBQUNBUyxVQUFNQyxTQUFOLEdBQWtCLEVBQWxCO0FBQ0FELFVBQU1FLFVBQU4sR0FBbUIsRUFBbkI7QUFIc0IsNENBSXRCLGlCQUFNRixLQUFOLENBSnNCO0FBS3ZCOztBQUVEOzs7Ozs7OztBQVJJRCxRLFdBZUpJLEcsa0JBQWdCO0FBQUEsUUFBWkgsS0FBWSx5REFBSixFQUFJOztBQUNkLFNBQUtJLE1BQUwsR0FBYyxLQUFLQSxNQUFMLElBQWUsRUFBN0I7O0FBRGMsUUFHTkEsTUFITSxHQUdvQkosS0FIcEIsQ0FHTkks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YXNrJztcbmltcG9ydCB7IHNwZWVkUGVyU2Vjb25kIH0gZnJvbSAnLi4vaW5jL2NhbGMnO1xuaW1wb3J0IHsgaXNOdW0sIGlzT2JqLCBpc1N0cmluZyB9IGZyb20gJy4uL2luYy91dGlscyc7XG5pbXBvcnQgZGV0ZWN0VmFsdWVUeXBlIGZyb20gJy4uL3ZhbHVlLXR5cGVzL2RldGVjdCc7XG5pbXBvcnQgTlVNRVJJQ0FMX1ZBTFVFUyBmcm9tICcuLi9pbmMvbnVtZXJpY2FsLXZhbHVlcyc7XG5pbXBvcnQgZGV0ZWN0QWRhcHRlciBmcm9tICcuLi9pbmMvZGV0ZWN0LWFkYXB0ZXInO1xuXG5jb25zdCBOVU1fTlVNRVJJQ0FMX1ZBTFVFUyA9IE5VTUVSSUNBTF9WQUxVRVMubGVuZ3RoO1xuXG5jb25zdCBkZWZhdWx0UmVuZGVyZXIgPSAoeyBzdGF0ZSwgYWRhcHRlciwgYWRhcHRlckRhdGEsIGVsZW1lbnQgfSkgPT4gYWRhcHRlcihlbGVtZW50LCBzdGF0ZSwgYWRhcHRlckRhdGEpO1xuXG5jb25zdCBjb252ZXJ0SWZTaG91bGRCZU51bWJlciA9ICh2YWx1ZSkgPT4gIWlzTmFOKHZhbHVlKSA/IHBhcnNlRmxvYXQodmFsdWUpIDogdmFsdWU7XG5cbmNsYXNzIEFjdGlvbiBleHRlbmRzIFRhc2sge1xuICBjb25zdHJ1Y3Rvcihwcm9wcyA9IHt9KSB7XG4gICAgcHJvcHMuc3RhdGUgPSB7fTtcbiAgICBwcm9wcy52YWx1ZUtleXMgPSBbXTtcbiAgICBwcm9wcy5wYXJlbnRLZXlzID0gW107XG4gICAgc3VwZXIocHJvcHMpO1xuICB9XG5cbiAgLypcbiAgICAjIFNldCBBY3Rpb24gcHJvcGVydGllc1xuICAgICMjIFNldCB1c2VyLWRlZmluZWQgQWN0aW9uIHByb3BlcnRpZXNcblxuICAgIEBwYXJhbSBbb2JqZWN0XVxuICAgIEByZXR1cm4gW0FjdGlvbl1cbiAgKi9cbiAgc2V0KHByb3BzID0ge30pIHtcbiAgICB0aGlzLnZhbHVlcyA9IHRoaXMudmFsdWVzIHx8IHt9O1xuXG4gICAgY29uc3QgeyB2YWx1ZXMsIC4uLnByb3BzVG9TZXQgfSA9IHByb3BzO1xuICAgIGNvbnN0IGluaGVyaXRhYmxlID0ge307XG5cbiAgICAvLyBTZXQgbm9uLWNvbnN1bWVkIHByb3BlcnRpZXNcbiAgICBzdXBlci5zZXQocHJvcHNUb1NldCk7XG5cbiAgICAvLyBEZXRlY3QgY29ycmVjdCBgYWRhcHRlcmAgaWYgbm9uZSBleGlzdHMgYW5kIGBlbGVtZW50YCBpcyBiZWluZyBzZXRcbiAgICBpZiAodGhpcy5lbGVtZW50KSB7XG4gICAgICBpZiAoIXRoaXMuYWRhcHRlcikge1xuICAgICAgICAvLyBEdWNrdHlwaXNoIGNoZWNrIGZvciBBZGFwdGVyXG4gICAgICAgIHRoaXMuYWRhcHRlciA9IGRldGVjdEFkYXB0ZXIodGhpcy5lbGVtZW50KTtcblxuICAgICAgICBpZiAodGhpcy5hZGFwdGVyLmdldEVsZW1lbnREYXRhKSB7XG4gICAgICAgICAgdGhpcy5hZGFwdGVyRGF0YSA9IHRoaXMuYWRhcHRlci5nZXRFbGVtZW50RGF0YSh0aGlzLmVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5vblJlbmRlcikge1xuICAgICAgICB0aGlzLm9uUmVuZGVyID0gZGVmYXVsdFJlbmRlcmVyO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFByaW1lIGFuIG9iamVjdCB0byBpbmhlcml0IGZyb20sIHdpdGggb25seSBgdmFsdWVgIHByb3BlcnRpZXNcbiAgICBmb3IgKGxldCBrZXkgaW4gdGhpcy5kZWZhdWx0VmFsdWUpIHtcbiAgICAgIGlmICh0aGlzLmRlZmF1bHRWYWx1ZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIGlmIChwcm9wc1RvU2V0Lmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICBpbmhlcml0YWJsZVtrZXldID0gcHJvcHNUb1NldFtrZXldO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXNba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaW5oZXJpdGFibGVba2V5XSA9IHRoaXNba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFVwZGF0ZSBleGlzdGluZyB2YWx1ZXMgd2l0aCBpbmhlcml0YWJsZSBwcm9wZXJ0aWVzXG4gICAgZm9yIChsZXQga2V5IGluIHRoaXMudmFsdWVzKSB7XG4gICAgICBpZiAodGhpcy52YWx1ZXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICB0aGlzLnZhbHVlc1trZXldID0geyAuLi50aGlzLnZhbHVlc1trZXldLCAuLi5pbmhlcml0YWJsZSB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFVwZGF0ZVxuICAgIGlmICh2YWx1ZXMpIHtcbiAgICAgIHRoaXMuc2V0VmFsdWVzKHZhbHVlcywgaW5oZXJpdGFibGUpO1xuXG4gICAgICAvLyBQcmVjb21wdXRlIG51bWJlciBvZiB2YWx1ZSBrZXkgYW5kIHBhcmVudCBrZXlzIHRvIGF2b2lkIHBlci1mcmFtZSBtZWFzdXJlbWVudFxuICAgICAgdGhpcy5udW1WYWx1ZUtleXMgPSB0aGlzLnZhbHVlS2V5cy5sZW5ndGg7XG4gICAgICB0aGlzLm51bVBhcmVudEtleXMgPSB0aGlzLnBhcmVudEtleXMubGVuZ3RoO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc2V0VmFsdWVzKHZhbHVlcywgaW5oZXJpdCkge1xuICAgIC8vIEl0ZXJhdGUgb3ZlciBhbGwgaW5jb21pbmcgdmFsdWVzIGFuZCBzZXRcbiAgICBmb3IgKGxldCBrZXkgaW4gdmFsdWVzKSB7XG4gICAgICBpZiAodmFsdWVzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgbGV0IGhhc0NoaWxkcmVuID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0ge307XG5cbiAgICAgICAgLy8gTWVyZ2UgaW50byBleGlzdGluZyB2YWx1ZSBvciBjcmVhdGUgbmV3XG4gICAgICAgIGNvbnN0IHZhbHVlQWxyZWFkeUV4aXN0cyA9IHRoaXMudmFsdWVzW2tleV0gIT09IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IG5ld1ZhbHVlID0gdmFsdWVBbHJlYWR5RXhpc3RzID8geyAuLi50aGlzLnZhbHVlc1trZXldIH0gOiB7IC4uLmluaGVyaXQgfTtcblxuICAgICAgICAvLyBJZiB2YWx1ZXMgaXMgbm90IGFuIG9iamVjdCwgYXNzaWduIHZhbHVlIHRvIGRlZmF1bHQgcHJvcFxuICAgICAgICBpZiAoIWlzT2JqKHZhbHVlc1trZXldKSkge1xuICAgICAgICAgIG5ld1ZhbHVlW3RoaXMuZGVmYXVsdFZhbHVlUHJvcF0gPSB2YWx1ZXNba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXdWYWx1ZSA9IHsgLi4ubmV3VmFsdWUsIC4uLnZhbHVlc1trZXldIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB3ZSd2ZSBnb3QgYW4gYWRhcHRlciwgZ2V0IHRoZSBjdXJyZW50IHZhbHVlXG4gICAgICAgIGlmIChuZXdWYWx1ZS5jdXJyZW50ID09PSB1bmRlZmluZWQgJiYgdGhpcy5hZGFwdGVyKSB7XG4gICAgICAgICAgbmV3VmFsdWUuY3VycmVudCA9IGNvbnZlcnRJZlNob3VsZEJlTnVtYmVyKHRoaXMuYWRhcHRlci5nZXQodGhpcy5lbGVtZW50LCBrZXkpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuZXdWYWx1ZS5mcm9tID09PSB1bmRlZmluZWQgJiYgdGhpcy5hZGFwdGVyKSB7XG4gICAgICAgICAgbmV3VmFsdWUuZnJvbSA9IG5ld1ZhbHVlLmN1cnJlbnQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBcHBseSBkZWZhdWx0IHZhbHVlIHByb3BlcnRpZXNcbiAgICAgICAgaWYgKCF2YWx1ZUFscmVhZHlFeGlzdHMpIHtcbiAgICAgICAgICBuZXdWYWx1ZSA9IHsgLi4udGhpcy5kZWZhdWx0VmFsdWUsIC4uLm5ld1ZhbHVlIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGEgdmFsdWUgdHlwZSBhbmQgd2UgZG8gaGF2ZSBhbiBBZGFwdGVyLCBjaGVjayBmb3IgdHlwZSB3aXRoIHZhbHVlIGtleVxuICAgICAgICBpZiAoIW5ld1ZhbHVlLnR5cGUgJiYgdGhpcy5hZGFwdGVyICYmIHRoaXMuYWRhcHRlci5jaGVja1ZhbHVlVHlwZSkge1xuICAgICAgICAgIG5ld1ZhbHVlLnR5cGUgPSB0aGlzLmFkYXB0ZXIuY2hlY2tWYWx1ZVR5cGUoa2V5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHdlIHN0aWxsIGRvbid0IGhhdmUgYSB2YWx1ZSB0eXBlIGFuZCB0aGlzIGlzIHRoZSBmaXJzdCB0aW1lIHdlJ3ZlIHNldCB0aGlzIHZhbHVlLCBjaGVjayBudW1lcmljYWwgdmFsdWVzIGZvciBzdHJpbmdzIGFuZCB0ZXN0XG4gICAgICAgIGlmICghbmV3VmFsdWUudHlwZSAmJiAhdGhpcy52YWx1ZXNba2V5XSkge1xuICAgICAgICAgIG5ld1ZhbHVlLnR5cGUgPSBkZXRlY3RWYWx1ZVR5cGUobmV3VmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBhIHZhbHVlIHR5cGUsIGhhbmRsZS4gVGhpcyBpcyBteSBsZWFzdCBmYXZvdXJpdGUgcGFydCBvZiBQb3Btb3Rpb24sIHNvLi4uIGVuam95LlxuICAgICAgICBpZiAobmV3VmFsdWUudHlwZSkge1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTlVNX05VTUVSSUNBTF9WQUxVRVM7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgcHJvcE5hbWUgPSBOVU1FUklDQUxfVkFMVUVTW2ldO1xuICAgICAgICAgICAgY29uc3QgdmFsdWVQcm9wID0gbmV3VmFsdWVbcHJvcE5hbWVdO1xuXG4gICAgICAgICAgICAvLyBJZiB0aGlzIHByb3AgaXMgYSBzdHJpbmcgYW5kIHdlIGhhdmUgYSBzcGxpdHRlciwgc3BsaXRcbiAgICAgICAgICAgIGlmIChuZXdWYWx1ZS50eXBlLmhhc093blByb3BlcnR5KCdzcGxpdCcpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHNwbGl0UHJvcCA9IGlzU3RyaW5nKHZhbHVlUHJvcCkgPyBuZXdWYWx1ZS50eXBlLnNwbGl0KHZhbHVlUHJvcCkgOiB7fTtcblxuICAgICAgICAgICAgICBmb3IgKGxldCBzcGxpdEtleSBpbiBzcGxpdFByb3ApIHtcbiAgICAgICAgICAgICAgICBpZiAoc3BsaXRQcm9wLmhhc093blByb3BlcnR5KHNwbGl0S2V5KSkge1xuICAgICAgICAgICAgICAgICAgY29uc3QgY29tYmluZWRLZXkgPSBrZXkgKyBzcGxpdEtleTtcblxuICAgICAgICAgICAgICAgICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhIGNoaWxkIHZhbHVlIGZvciB0aGlzIGtleSwgbWFrZSBvbmVcbiAgICAgICAgICAgICAgICAgIGlmICghY2hpbGRyZW5bY29tYmluZWRLZXldKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRWYWx1ZSA9IChuZXdWYWx1ZS50eXBlLmRlZmF1bHRQcm9wcyAmJiBuZXdWYWx1ZS50eXBlLmRlZmF1bHRQcm9wc1tzcGxpdEtleV0pID8gbmV3VmFsdWUudHlwZS5kZWZhdWx0UHJvcHNbc3BsaXRLZXldIDogbmV3VmFsdWUudHlwZS5kZWZhdWx0UHJvcHMgfHwge307XG5cbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW5bY29tYmluZWRLZXldID0ge1xuICAgICAgICAgICAgICAgICAgICAgIC4uLm5ld1ZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgIC4uLmRlZmF1bHRWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGtleSxcbiAgICAgICAgICAgICAgICAgICAgICBjaGlsZEtleTogc3BsaXRLZXlcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgY2hpbGRyZW5bY29tYmluZWRLZXldLnR5cGU7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIGhhc0NoaWxkcmVuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIGNoaWxkcmVuW2NvbWJpbmVkS2V5XVtwcm9wTmFtZV0gPSBwYXJzZUZsb2F0KHNwbGl0UHJvcFtzcGxpdEtleV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgYSB0ZW1wbGF0ZSBmdW5jdGlvbiwgZ2VuZXJhdGVcbiAgICAgICAgICAgICAgaWYgKCFuZXdWYWx1ZS50ZW1wbGF0ZSAmJiBuZXdWYWx1ZS50eXBlLnRlbXBsYXRlICYmIGlzU3RyaW5nKHZhbHVlUHJvcCkpIHtcbiAgICAgICAgICAgICAgICBuZXdWYWx1ZS50ZW1wbGF0ZSA9IG5ld1ZhbHVlLnR5cGUudGVtcGxhdGUodmFsdWVQcm9wKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChuZXdWYWx1ZS50eXBlLmRlZmF1bHRQcm9wcykge1xuICAgICAgICAgICAgICBuZXdWYWx1ZSA9IHsgLi4ubmV3VmFsdWUsIC4uLm5ld1ZhbHVlLnR5cGUuZGVmYXVsdFByb3BzIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZVByb3AgIT09IHVuZGVmaW5lZCAmJiBuZXdWYWx1ZS50eXBlLnBhcnNlKSB7XG4gICAgICAgICAgICAgIG5ld1ZhbHVlW3Byb3BOYW1lXSA9IG5ld1ZhbHVlLnR5cGUucGFyc2UodmFsdWVQcm9wLCBuZXdWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIEVuZCB2YWx1ZSB0eXBlIG5vbnNlbnNlXG5cbiAgICAgICAgLy8gU2V0IGBwcmV2YCB0byBgY3VycmVudGAgZm9yIGZpcnN0IGZyYW1lIGFmdGVyIHNldFxuICAgICAgICBuZXdWYWx1ZS5wcmV2ID0gbmV3VmFsdWUuY3VycmVudDtcbiAgICAgICAgXG4gICAgICAgIC8vIElmIHRoaXMgdmFsdWUgZG9lc24ndCBoYXZlIGNoaWxkcmVuLCBhZGQgdG8gdmFsdWVLZXlzXG4gICAgICAgIGlmICghaGFzQ2hpbGRyZW4pIHtcbiAgICAgICAgICBpZiAodGhpcy52YWx1ZUtleXMuaW5kZXhPZihrZXkpID09PSAtMSkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZUtleXMucHVzaChrZXkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAvLyBPciBhZGQgdG8gcGFyZW50S2V5c1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld1ZhbHVlLmNoaWxkcmVuID0gbmV3VmFsdWUuY2hpbGRyZW4gfHwge307XG5cbiAgICAgICAgICBpZiAodGhpcy5wYXJlbnRLZXlzLmluZGV4T2Yoa2V5KSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMucGFyZW50S2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5zZXRWYWx1ZXMoY2hpbGRyZW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy52YWx1ZXNba2V5XSA9IG5ld1ZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qXG4gICAgRGVjaWRlIHdoZXRoZXIgdGhpcyBBY3Rpb24gd2lsbCByZW5kZXIgb24gbmV4dCBmcmFtZVxuXG4gICAgQHBhcmFtIFtBY3Rpb25dXG4gICAgQHBhcmFtIFtudW1iZXJdXG4gICAgQHBhcmFtIFtudW1iZXJdXG4gICAgQHJldHVybiBbYm9vbGVhbl06IFJldHVybiB0cnVlIHRvIHJlbmRlclxuICAqL1xuICB3aWxsUmVuZGVyKGFjdGlvbiwgZnJhbWVTdGFtcCwgZWxhcHNlZCkge1xuICAgIGxldCBoYXNDaGFuZ2VkID0gZmFsc2U7XG5cbiAgICAvLyBDaGVjayBpZiBiYXNlIHZhbHVlcyBoYXZlIHVwZGF0ZWQgXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm51bVZhbHVlS2V5czsgaSsrKSB7XG4gICAgICBjb25zdCBrZXkgPSB0aGlzLnZhbHVlS2V5c1tpXTtcbiAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy52YWx1ZXNba2V5XTtcblxuICAgICAgLy8gUnVuIHRyYW5zZm9ybSBmdW5jdGlvbiAoaWYgcHJlc2VudClcbiAgICAgIGlmICh2YWx1ZS50cmFuc2Zvcm0pIHtcbiAgICAgICAgdmFsdWUuY3VycmVudCA9IHZhbHVlLnRyYW5zZm9ybSh2YWx1ZS5jdXJyZW50LCBrZXksIHRoaXMpO1xuICAgICAgfVxuXG4gICAgICAvLyBDYXAgbWluaW11bVxuICAgICAgaWYgKGlzTnVtKHZhbHVlLm1pbikpIHtcbiAgICAgICAgdmFsdWUuY3VycmVudCA9IE1hdGgubWF4KHZhbHVlLmN1cnJlbnQsIHZhbHVlLm1pbik7XG4gICAgICB9XG5cbiAgICAgIC8vIENhcCBtYXhpbXVtXG4gICAgICBpZiAoaXNOdW0odmFsdWUubWF4KSkge1xuICAgICAgICB2YWx1ZS5jdXJyZW50ID0gTWF0aC5taW4odmFsdWUuY3VycmVudCwgdmFsdWUubWF4KTtcbiAgICAgIH1cblxuICAgICAgLy8gUm91bmQgbnVtYmVyXG4gICAgICBpZiAodmFsdWUucm91bmQpIHtcbiAgICAgICAgdmFsdWUuY3VycmVudCA9IE1hdGgucm91bmQodmFsdWUuY3VycmVudCk7XG4gICAgICB9XG5cbiAgICAgIHZhbHVlLmZyYW1lQ2hhbmdlID0gdmFsdWUuY3VycmVudCAtIHZhbHVlLnByZXY7XG5cbiAgICAgIC8vIFVwZGF0ZSB2ZWxvY2l0eVxuICAgICAgaWYgKCF0aGlzLmNhbGN1bGF0ZXNWZWxvY2l0eSkge1xuICAgICAgICB2YWx1ZS52ZWxvY2l0eSA9IHNwZWVkUGVyU2Vjb25kKHZhbHVlLmZyYW1lQ2hhbmdlLCBlbGFwc2VkKTtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgdGhpcyB2YWx1ZSBoYXMgY2hhbmdlZFxuICAgICAgaWYgKHZhbHVlLnByZXYgIT09IHZhbHVlLmN1cnJlbnQpIHtcbiAgICAgICAgaGFzQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgIHZhbHVlLnByZXYgPSB2YWx1ZS5jdXJyZW50O1xuICAgICAgfVxuXG4gICAgICAvLyBBcHBlbmQgdW5pdFxuICAgICAgY29uc3QgdmFsdWVGb3JTdGF0ZSA9ICh2YWx1ZS50eXBlICYmIHZhbHVlLnR5cGUuc2VyaWFsaXplKSA/IHZhbHVlLnR5cGUuc2VyaWFsaXplKHZhbHVlLmN1cnJlbnQsIHZhbHVlKSA6IHZhbHVlLmN1cnJlbnQ7XG5cbiAgICAgIC8vIEFkZCB0byBzdGF0ZSBpZiB0aGlzIGlzIG5vdCBhIGNoaWxkIHZhdWVcbiAgICAgIGlmICghdmFsdWUucGFyZW50KSB7XG4gICAgICAgIHRoaXMuc3RhdGVba2V5XSA9IHZhbHVlRm9yU3RhdGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnZhbHVlc1t2YWx1ZS5wYXJlbnRdLmNoaWxkcmVuW3ZhbHVlLmNoaWxkS2V5XSA9IHZhbHVlRm9yU3RhdGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIHBhcmVudCB2YWx1ZXNcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubnVtUGFyZW50S2V5czsgaSsrKSB7XG4gICAgICBjb25zdCBrZXkgPSB0aGlzLnBhcmVudEtleXNbaV07XG4gICAgICBjb25zdCB2YWx1ZSA9IHRoaXMudmFsdWVzW2tleV07XG5cbiAgICAgIHZhbHVlLmN1cnJlbnQgPSB2YWx1ZS50eXBlLmNvbWJpbmUodmFsdWUuY2hpbGRyZW4sIHZhbHVlLnRlbXBsYXRlKTtcblxuICAgICAgdGhpcy5zdGF0ZVtrZXldID0gdmFsdWUuY3VycmVudDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vbkZyYW1lKSB7XG4gICAgICB0aGlzLm9uRnJhbWUodGhpcy5zdGF0ZSwgdGhpcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuICh0aGlzLm9uQ2xlYW51cCkgPyB0cnVlIDogaGFzQ2hhbmdlZDtcbiAgfVxuXG4gIGluaGVyaXQocHJvcHMgPSB7fSkge1xuICAgIGNvbnN0IHsgdmFsdWVzLCAuLi5wcm9wc1RvU2V0IH0gPSBwcm9wcztcbiAgICBjb25zdCBuZXdBY3Rpb24gPSBzdXBlci5pbmhlcml0KHByb3BzVG9TZXQpO1xuXG4gICAgaWYgKHZhbHVlcykge1xuICAgICAgbmV3QWN0aW9uLnNldCh7IHZhbHVlcyB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3QWN0aW9uO1xuICB9XG5cbiAgcGF1c2UoKSB7XG4gICAgc3VwZXIuc3RvcCgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgcmVzdW1lKCkge1xuICAgIHN1cGVyLnN0YXJ0KCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB0b2dnbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNBY3RpdmUgPyB0aGlzLnBhdXNlKCkgOiB0aGlzLnJlc3VtZSgpO1xuICB9XG5cbiAgc3RhcnQoKSB7XG4gICAgY29uc3QgdmFsdWVzID0gdGhpcy52YWx1ZXM7XG4gICAgc3VwZXIuc3RhcnQoKTtcblxuICAgIGZvciAobGV0IGtleSBpbiB2YWx1ZXMpIHtcbiAgICAgIGlmICh2YWx1ZXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICB2YWx1ZXNba2V5XS5wcmV2ID0gdmFsdWVzW2tleV0ub3JpZ2luID0gdmFsdWVzW2tleV0uY3VycmVudDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHN0YXRpYyBleHRlbmREZWZhdWx0VmFsdWUocHJvcHMpIHtcbiAgICByZXR1cm4geyAuLi50aGlzLnByb3RvdHlwZS5kZWZhdWx0VmFsdWUsIC4uLnByb3BzIH07XG4gIH1cblxuICBzdGF0aWMgZXh0ZW5kRGVmYXVsdFByb3BzKHByb3BzKSB7XG4gICAgcmV0dXJuIHsgLi4udGhpcy5wcm90b3R5cGUuZGVmYXVsdFByb3BzLCAuLi5wcm9wcyB9O1xuICB9XG59XG5cbkFjdGlvbi5wcm90b3R5cGUuZGVmYXVsdFZhbHVlUHJvcCA9ICdjdXJyZW50JztcbkFjdGlvbi5wcm90b3R5cGUuZGVmYXVsdFZhbHVlID0ge1xuICBjdXJyZW50OiAwLFxuICB2ZWxvY2l0eTogMCxcbiAgcm91bmQ6IGZhbHNlLFxuICBtaW46IHVuZGVmaW5lZCxcbiAgbWF4OiB1bmRlZmluZWQsXG4gIHRyYW5zZm9ybTogdW5kZWZpbmVkXG59O1xuXG5leHBvcnQgZGVmYXVsdCBBY3Rpb247XG4iXX0=