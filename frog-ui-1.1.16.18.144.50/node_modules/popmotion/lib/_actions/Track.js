'use strict';

exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _Action2 = require('./Action');

var _Action3 = _interopRequireDefault(_Action2);

var _Pointer = require('../input/Pointer');

var _Pointer2 = _interopRequireDefault(_Pointer);

var _calc = require('../inc/calc');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/*
  Scrape x/y coordinates from provided event

  @param [event]
  @return [object]
*/
var mouseEventToPoint = function (e) {
  return {
    x: e.pageX,
    y: e.pageY
  };
};

var touchEventToPoint = function (_ref) {
  var changedTouches = _ref.changedTouches;
  return {
    x: changedTouches[0].clientX,
    y: changedTouches[0].clientY
  };
};

var createPointer = function (e) {
  return e.touches ? new _Pointer2.default(touchEventToPoint(e), 'touchmove', touchEventToPoint) : new _Pointer2.default(mouseEventToPoint(e), 'mousemove', mouseEventToPoint);
};

var getActualEvent = function (e) {
  return e.originalEvent || e;
};

var Track = function (_Action) {
  _inherits(Track, _Action);

  function Track() {
    _classCallCheck(this, Track);

    return _possibleConstructorReturn(this, _Action.apply(this, arguments));
  }

  Track.prototype.start = function start(input) {
    _Action.prototype.start.call(this);

    if (input) {
      this.input = input.state ? input : createPointer(getActualEvent(input));
    }

    this.inputOffset = {};
    this.inputOrigin = _extends({}, this.input.state);
    this.input.start();
  };

  Track.prototype.stop = function stop() {
    _Action.prototype.stop.call(this);
    this.input.stop();
  };

  Track.prototype.onUpdate = function onUpdate(track, frameStamp, elapsed) {
    this.inputOffset = (0, _calc.offset)(this.inputOrigin, this.input.state);

    for (var i = 0; i < this.numValueKeys; i++) {
      var key = this.valueKeys[i];

      if (this.inputOffset.hasOwnProperty(key)) {
        var value = this.values[key];
        var inputProp = value.hasOwnProperty('watch') ? value.watch : key;

        if (value.direct) {
          value.current = this.input.state[inputProp];
        } else {
          value.current = value.from + this.inputOffset[inputProp];
        }

        // Smooth value if we have smoothing
        if (value.smooth) {
          value.current = (0, _calc.smooth)(value.current, value.prev, elapsed, value.smooth);
        }
      }
    }
  };

  return Track;
}(_Action3.default);

Track.prototype.defaultValueProp = 'watch';
Track.prototype.defaultValue = _Action3.default.extendDefaultValue({
  direct: false
});

exports.default = Track;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9fYWN0aW9ucy9UcmFjay5qcyJdLCJuYW1lcyI6WyJtb3VzZUV2ZW50VG9Qb2ludCIsImUiLCJ4IiwicGFnZVgiLCJ5IiwicGFnZVkiLCJ0b3VjaEV2ZW50VG9Qb2ludCIsImNoYW5nZWRUb3VjaGVzIiwiY2xpZW50WCIsImNsaWVudFkiLCJjcmVhdGVQb2ludGVyIiwidG91Y2hlcyIsImdldEFjdHVhbEV2ZW50Iiwib3JpZ2luYWxFdmVudCIsIlRyYWNrIiwic3RhcnQiLCJpbnB1dCIsInN0YXRlIiwiaW5wdXRPZmZzZXQiLCJpbnB1dE9yaWdpbiIsInN0b3AiLCJvblVwZGF0ZSIsInRyYWNrIiwiZnJhbWVTdGFtcCIsImVsYXBzZWQiLCJpIiwibnVtVmFsdWVLZXlzIiwia2V5IiwidmFsdWVLZXlzIiwiaGFzT3duUHJvcGVydHkiLCJ2YWx1ZSIsInZhbHVlcyIsImlucHV0UHJvcCIsIndhdGNoIiwiZGlyZWN0IiwiY3VycmVudCIsImZyb20iLCJzbW9vdGgiLCJwcmV2IiwicHJvdG90eXBlIiwiZGVmYXVsdFZhbHVlUHJvcCIsImRlZmF1bHRWYWx1ZSIsImV4dGVuZERlZmF1bHRWYWx1ZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7Ozs7O0FBRUE7Ozs7OztBQU1BLElBQU1BLG9CQUFvQixVQUFDQyxDQUFEO0FBQUEsU0FBUTtBQUNoQ0MsT0FBR0QsRUFBRUUsS0FEMkI7QUFFaENDLE9BQUdILEVBQUVJO0FBRjJCLEdBQVI7QUFBQSxDQUExQjs7QUFLQSxJQUFNQyxvQkFBb0I7QUFBQSxNQUFHQyxjQUFILFFBQUdBLGNBQUg7QUFBQSxTQUF5QjtBQUNqREwsT0FBR0ssZUFBZSxDQUFmLEVBQWtCQyxPQUQ0QjtBQUVqREosT0FBR0csZUFBZSxDQUFmLEVBQWtCRTtBQUY0QixHQUF6QjtBQUFBLENBQTFCOztBQUtBLElBQU1DLGdCQUFnQixVQUFDVCxDQUFEO0FBQUEsU0FBT0EsRUFBRVUsT0FBRixHQUMzQixzQkFBWUwsa0JBQWtCTCxDQUFsQixDQUFaLEVBQWtDLFdBQWxDLEVBQStDSyxpQkFBL0MsQ0FEMkIsR0FFM0Isc0JBQVlOLGtCQUFrQkMsQ0FBbEIsQ0FBWixFQUFrQyxXQUFsQyxFQUErQ0QsaUJBQS9DLENBRm9CO0FBQUEsQ0FBdEI7O0FBSUEsSUFBTVksaUJBQWlCLFVBQUNYLENBQUQ7QUFBQSxTQUFPQSxFQUFFWSxhQUFGLElBQW1CWixDQUExQjtBQUFBLENBQXZCOztJQUVNYSxLO1lBQUFBLEs7O1dBQUFBLEs7MEJBQUFBLEs7Ozs7O0FBQUFBLE8sV0FDSkMsSyxrQkFBTUMsSyxFQUFPO0FBQ1gsc0JBQU1ELEtBQU47O0FBRUEsUUFBSUMsS0FBSixFQUFXO0FBQ1QsV0FBS0EsS0FBTCxHQUFhQSxNQUFNQyxLQUFOLEdBQWNELEtBQWQsR0FBc0JOLGNBQWNFLGVBQWVJLEtBQWYsQ0FBZCxDQUFuQztBQUNEOztBQUVELFNBQUtFLFdBQUwsR0FBbUIsRUFBbkI7QUFDQSxTQUFLQyxXQUFMLGdCQUF3QixLQUFLSCxLQUFMLENBQVdDLEtBQW5DO0FBQ0EsU0FBS0QsS0FBTCxDQUFXRCxLQUFYO0FBQ0QsRzs7QUFYR0QsTyxXQWFKTSxJLG1CQUFPO0FBQ0wsc0JBQU1BLElBQU47QUFDQSxTQUFLSixLQUFMLENBQVdJLElBQVg7QUFDRCxHOztBQWhCR04sTyxXQWtCSk8sUSxxQkFBU0MsSyxFQUFPQyxVLEVBQVlDLE8sRUFBUztBQUNuQyxTQUFLTixXQUFMLEdBQW1CLGtCQUFPLEtBQUtDLFdBQVosRUFBeUIsS0FBS0gsS0FBTCxDQUFXQyxLQUFwQyxDQUFuQjs7QUFFQSxTQUFLLElBQUlRLElBQUksQ0FBYixFQUFnQkEsSUFBSSxLQUFLQyxZQUF6QixFQUF1Q0QsR0FBdkMsRUFBNEM7QUFDMUMsVUFBTUUsTUFBTSxLQUFLQyxTQUFMLENBQWVILENBQWYsQ0FBWjs7QUFFQSxVQUFJLEtBQUtQLFdBQUwsQ0FBaUJXLGNBQWpCLENBQWdDRixHQUFoQyxDQUFKLEVBQTBDO0FBQ3hDLFlBQU1HLFFBQVEsS0FBS0MsTUFBTCxDQUFZSixHQUFaLENBQWQ7QUFDQSxZQUFNSyxZQUFZRixNQUFNRCxjQUFOLENBQXFCLE9BQXJCLElBQWdDQyxNQUFNRyxLQUF0QyxHQUE4Q04sR0FBaEU7O0FBRUEsWUFBSUcsTUFBTUksTUFBVixFQUFrQjtBQUNoQkosZ0JBQU1LLE9BQU4sR0FBZ0IsS0FBS25CLEtBQUwsQ0FBV0MsS0FBWCxDQUFpQmUsU0FBakIsQ0FBaEI7QUFDRCxTQUZELE1BRU87QUFDTEYsZ0JBQU1LLE9BQU4sR0FBZ0JMLE1BQU1NLElBQU4sR0FBYSxLQUFLbEIsV0FBTCxDQUFpQmMsU0FBakIsQ0FBN0I7QUFDRDs7QUFFRDtBQUNBLFlBQUlGLE1BQU1PLE1BQVYsRUFBa0I7QUFDaEJQLGdCQUFNSyxPQUFOLEdBQWdCLGtCQUFPTCxNQUFNSyxPQUFiLEVBQXNCTCxNQUFNUSxJQUE1QixFQUFrQ2QsT0FBbEMsRUFBMkNNLE1BQU1PLE1BQWpELENBQWhCO0FBQ0Q7QUFDRjtBQUNGO0FBQ0YsRzs7U0F4Q0d2QixLOzs7QUEyQ05BLE1BQU15QixTQUFOLENBQWdCQyxnQkFBaEIsR0FBbUMsT0FBbkM7QUFDQTFCLE1BQU15QixTQUFOLENBQWdCRSxZQUFoQixHQUErQixpQkFBT0Msa0JBQVAsQ0FBMEI7QUFDdkRSLFVBQVE7QUFEK0MsQ0FBMUIsQ0FBL0I7O2tCQUllcEIsSyIsImZpbGUiOiJUcmFjay5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBBY3Rpb24gZnJvbSAnLi9BY3Rpb24nO1xuaW1wb3J0IFBvaW50ZXIgZnJvbSAnLi4vaW5wdXQvUG9pbnRlcic7XG5pbXBvcnQgeyBzbW9vdGgsIG9mZnNldCB9IGZyb20gJy4uL2luYy9jYWxjJztcblxuLypcbiAgU2NyYXBlIHgveSBjb29yZGluYXRlcyBmcm9tIHByb3ZpZGVkIGV2ZW50XG5cbiAgQHBhcmFtIFtldmVudF1cbiAgQHJldHVybiBbb2JqZWN0XVxuKi9cbmNvbnN0IG1vdXNlRXZlbnRUb1BvaW50ID0gKGUpID0+ICh7XG4gIHg6IGUucGFnZVgsXG4gIHk6IGUucGFnZVlcbn0pO1xuXG5jb25zdCB0b3VjaEV2ZW50VG9Qb2ludCA9ICh7IGNoYW5nZWRUb3VjaGVzIH0pID0+ICh7XG4gIHg6IGNoYW5nZWRUb3VjaGVzWzBdLmNsaWVudFgsXG4gIHk6IGNoYW5nZWRUb3VjaGVzWzBdLmNsaWVudFlcbn0pO1xuXG5jb25zdCBjcmVhdGVQb2ludGVyID0gKGUpID0+IGUudG91Y2hlcyA/XG4gIG5ldyBQb2ludGVyKHRvdWNoRXZlbnRUb1BvaW50KGUpLCAndG91Y2htb3ZlJywgdG91Y2hFdmVudFRvUG9pbnQpIDogXG4gIG5ldyBQb2ludGVyKG1vdXNlRXZlbnRUb1BvaW50KGUpLCAnbW91c2Vtb3ZlJywgbW91c2VFdmVudFRvUG9pbnQpO1xuXG5jb25zdCBnZXRBY3R1YWxFdmVudCA9IChlKSA9PiBlLm9yaWdpbmFsRXZlbnQgfHwgZTtcblxuY2xhc3MgVHJhY2sgZXh0ZW5kcyBBY3Rpb24ge1xuICBzdGFydChpbnB1dCkge1xuICAgIHN1cGVyLnN0YXJ0KCk7XG5cbiAgICBpZiAoaW5wdXQpIHtcbiAgICAgIHRoaXMuaW5wdXQgPSBpbnB1dC5zdGF0ZSA/IGlucHV0IDogY3JlYXRlUG9pbnRlcihnZXRBY3R1YWxFdmVudChpbnB1dCkpO1xuICAgIH1cblxuICAgIHRoaXMuaW5wdXRPZmZzZXQgPSB7fTtcbiAgICB0aGlzLmlucHV0T3JpZ2luID0geyAuLi50aGlzLmlucHV0LnN0YXRlIH07XG4gICAgdGhpcy5pbnB1dC5zdGFydCgpO1xuICB9XG5cbiAgc3RvcCgpIHtcbiAgICBzdXBlci5zdG9wKCk7XG4gICAgdGhpcy5pbnB1dC5zdG9wKCk7XG4gIH1cblxuICBvblVwZGF0ZSh0cmFjaywgZnJhbWVTdGFtcCwgZWxhcHNlZCkge1xuICAgIHRoaXMuaW5wdXRPZmZzZXQgPSBvZmZzZXQodGhpcy5pbnB1dE9yaWdpbiwgdGhpcy5pbnB1dC5zdGF0ZSk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubnVtVmFsdWVLZXlzOyBpKyspIHtcbiAgICAgIGNvbnN0IGtleSA9IHRoaXMudmFsdWVLZXlzW2ldO1xuXG4gICAgICBpZiAodGhpcy5pbnB1dE9mZnNldC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy52YWx1ZXNba2V5XTtcbiAgICAgICAgY29uc3QgaW5wdXRQcm9wID0gdmFsdWUuaGFzT3duUHJvcGVydHkoJ3dhdGNoJykgPyB2YWx1ZS53YXRjaCA6IGtleTtcblxuICAgICAgICBpZiAodmFsdWUuZGlyZWN0KSB7XG4gICAgICAgICAgdmFsdWUuY3VycmVudCA9IHRoaXMuaW5wdXQuc3RhdGVbaW5wdXRQcm9wXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZS5jdXJyZW50ID0gdmFsdWUuZnJvbSArIHRoaXMuaW5wdXRPZmZzZXRbaW5wdXRQcm9wXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNtb290aCB2YWx1ZSBpZiB3ZSBoYXZlIHNtb290aGluZ1xuICAgICAgICBpZiAodmFsdWUuc21vb3RoKSB7XG4gICAgICAgICAgdmFsdWUuY3VycmVudCA9IHNtb290aCh2YWx1ZS5jdXJyZW50LCB2YWx1ZS5wcmV2LCBlbGFwc2VkLCB2YWx1ZS5zbW9vdGgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cblRyYWNrLnByb3RvdHlwZS5kZWZhdWx0VmFsdWVQcm9wID0gJ3dhdGNoJztcblRyYWNrLnByb3RvdHlwZS5kZWZhdWx0VmFsdWUgPSBBY3Rpb24uZXh0ZW5kRGVmYXVsdFZhbHVlKHtcbiAgZGlyZWN0OiBmYWxzZVxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IFRyYWNrO1xuIl19