'use strict';

exports.__esModule = true;
exports.default = cubicBezier;
/*
  Bezier function generator
    
  GaÃ«tan Renaudeau's BezierEasing
  https://github.com/gre/bezier-easing/blob/master/index.js  
  https://github.com/gre/bezier-easing/blob/master/LICENSE
  You're a hero
  
  Use
  
    var easeOut = new Bezier(.17,.67,.83,.67),
      x = easeOut(0.5); // returns 0.627...
*/

// Constants
var NEWTON_ITERATIONS = 8;
var NEWTON_MIN_SLOPE = 0.001;
var SUBDIVISION_PRECISION = 0.0000001;
var SUBDIVISION_MAX_ITERATIONS = 10;
var K_SPLINE_TABLE_SIZE = 11;
var K_SAMPLE_STEP_SIZE = 1.0 / (K_SPLINE_TABLE_SIZE - 1.0);
var FLOAT_32_SUPPORTED = typeof Float32Array !== 'undefined';

// Helper methods
var a = function (a1, a2) {
  return 1.0 - 3.0 * a2 + 3.0 * a1;
};
var b = function (a1, a2) {
  return 3.0 * a2 - 6.0 * a1;
};
var c = function (a1) {
  return 3.0 * a1;
};

var getSlope = function (t, a1, a2) {
  return 3.0 * a(a1, a2) * t * t + 2.0 * b(a1, a2) * t + c(a1);
};

var calcBezier = function (t, a1, a2) {
  return ((a(a1, a2) * t + b(a1, a2)) * t + c(a1)) * t;
};

/*
  Create a cubic bezier resolver
*/
function cubicBezier(mX1, mY1, mX2, mY2) {
  var sampleValues = FLOAT_32_SUPPORTED ? new Float32Array(K_SPLINE_TABLE_SIZE) : new Array(K_SPLINE_TABLE_SIZE);
  var _precomputed = false;

  var binarySubdivide = function (aX, aA, aB) {
    var i = 0;
    var currentX = void 0;
    var currentT = void 0;

    do {
      currentT = aA + (aB - aA) / 2.0;
      currentX = calcBezier(currentT, mX1, mX2) - aX;
      if (currentX > 0.0) {
        aB = currentT;
      } else {
        aA = currentT;
      }
    } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);

    return currentT;
  };

  var newtonRaphsonIterate = function (aX, aGuessT) {
    var i = 0;
    var currentSlope = 0;
    var currentX = void 0;

    for (; i < NEWTON_ITERATIONS; ++i) {
      currentSlope = getSlope(aGuessT, mX1, mX2);

      if (currentSlope === 0.0) {
        return aGuessT;
      }

      currentX = calcBezier(aGuessT, mX1, mX2) - aX;
      aGuessT -= currentX / currentSlope;
    }

    return aGuessT;
  };

  var calcSampleValues = function () {
    for (var i = 0; i < K_SPLINE_TABLE_SIZE; ++i) {
      sampleValues[i] = calcBezier(i * K_SAMPLE_STEP_SIZE, mX1, mX2);
    }
  };

  var getTForX = function (aX) {
    var intervalStart = 0.0;
    var currentSample = 1;
    var lastSample = K_SPLINE_TABLE_SIZE - 1;
    var dist = 0.0;
    var guessForT = 0.0;
    var initialSlope = 0.0;

    for (; currentSample != lastSample && sampleValues[currentSample] <= aX; ++currentSample) {
      intervalStart += K_SAMPLE_STEP_SIZE;
    }

    --currentSample;

    dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);
    guessForT = intervalStart + dist * K_SAMPLE_STEP_SIZE;

    initialSlope = getSlope(guessForT, mX1, mX2);

    // If slope is greater than min
    if (initialSlope >= NEWTON_MIN_SLOPE) {
      return newtonRaphsonIterate(aX, guessForT);
      // Slope is equal to min
    } else if (initialSlope === 0.0) {
      return guessForT;
      // Slope is less than min
    } else {
      return binarySubdivide(aX, intervalStart, intervalStart + K_SAMPLE_STEP_SIZE);
    }
  };

  var precompute = function () {
    _precomputed = true;
    if (mX1 != mY1 || mX2 != mY2) {
      calcSampleValues();
    }
  };

  var resolver = function (aX) {
    var returnValue = void 0;

    if (!_precomputed) {
      precompute();
    }

    // If linear gradient, return X as T
    if (mX1 === mY1 && mX2 === mY2) {
      returnValue = aX;

      // If at start, return 0
    } else if (aX === 0) {
      returnValue = 0;

      // If at end, return 1
    } else if (aX === 1) {
      returnValue = 1;
    } else {
      returnValue = calcBezier(getTForX(aX), mY1, mY2);
    }

    return returnValue;
  };

  return resolver;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9fYWN0aW9ucy9lYXNpbmcvY3JlYXRlLWJlemllci5qcyJdLCJuYW1lcyI6WyJjdWJpY0JlemllciIsIk5FV1RPTl9JVEVSQVRJT05TIiwiTkVXVE9OX01JTl9TTE9QRSIsIlNVQkRJVklTSU9OX1BSRUNJU0lPTiIsIlNVQkRJVklTSU9OX01BWF9JVEVSQVRJT05TIiwiS19TUExJTkVfVEFCTEVfU0laRSIsIktfU0FNUExFX1NURVBfU0laRSIsIkZMT0FUXzMyX1NVUFBPUlRFRCIsIkZsb2F0MzJBcnJheSIsImEiLCJhMSIsImEyIiwiYiIsImMiLCJnZXRTbG9wZSIsInQiLCJjYWxjQmV6aWVyIiwibVgxIiwibVkxIiwibVgyIiwibVkyIiwic2FtcGxlVmFsdWVzIiwiQXJyYXkiLCJfcHJlY29tcHV0ZWQiLCJiaW5hcnlTdWJkaXZpZGUiLCJhWCIsImFBIiwiYUIiLCJpIiwiY3VycmVudFgiLCJjdXJyZW50VCIsIk1hdGgiLCJhYnMiLCJuZXd0b25SYXBoc29uSXRlcmF0ZSIsImFHdWVzc1QiLCJjdXJyZW50U2xvcGUiLCJjYWxjU2FtcGxlVmFsdWVzIiwiZ2V0VEZvclgiLCJpbnRlcnZhbFN0YXJ0IiwiY3VycmVudFNhbXBsZSIsImxhc3RTYW1wbGUiLCJkaXN0IiwiZ3Vlc3NGb3JUIiwiaW5pdGlhbFNsb3BlIiwicHJlY29tcHV0ZSIsInJlc29sdmVyIiwicmV0dXJuVmFsdWUiXSwibWFwcGluZ3MiOiI7OztrQkFtQ3dCQSxXO0FBbkN4Qjs7Ozs7Ozs7Ozs7Ozs7QUFjQTtBQUNBLElBQU1DLG9CQUFvQixDQUExQjtBQUNBLElBQU1DLG1CQUFtQixLQUF6QjtBQUNBLElBQU1DLHdCQUF3QixTQUE5QjtBQUNBLElBQU1DLDZCQUE2QixFQUFuQztBQUNBLElBQU1DLHNCQUFzQixFQUE1QjtBQUNBLElBQU1DLHFCQUFxQixPQUFPRCxzQkFBc0IsR0FBN0IsQ0FBM0I7QUFDQSxJQUFNRSxxQkFBc0IsT0FBT0MsWUFBUCxLQUF3QixXQUFw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ekIsRUFBOEI7QUFDNUJnQjtBQUNEO0FBQ0YsR0FMRDs7QUFPQSxNQUFNUyxXQUFXLFVBQUNwQixFQUFELEVBQVE7QUFDdkIsUUFBSXFCLG9CQUFKOztBQUVBLFFBQUksQ0FBQ3ZCLFlBQUwsRUFBbUI7QUFDakJxQjtBQUNEOztBQUVEO0FBQ0EsUUFBSTNCLFFBQVFDLEdBQVIsSUFBZUMsUUFBUUMsR0FBM0IsRUFBZ0M7QUFDOUIwQixvQkFBY3JCLEVBQWQ7O0FBRUY7QUFDQyxLQUpELE1BSU8sSUFBSUEsT0FBTyxDQUFYLEVBQWM7QUFDbkJxQixvQkFBYyxDQUFkOztBQUVGO0FBQ0MsS0FKTSxNQUlBLElBQUlyQixPQUFPLENBQVgsRUFBYztBQUNuQnFCLG9CQUFjLENBQWQ7QUFFRCxLQUhNLE1BR0E7QUFDTEEsb0JBQWM5QixXQUFXcUIsU0FBU1osRUFBVCxDQUFYLEVBQXlCUCxHQUF6QixFQUE4QkUsR0FBOUIsQ0FBZDtBQUNEOztBQUVELFdBQU8wQixXQUFQO0FBQ0QsR0F4QkQ7O0FBMEJBLFNBQU9ELFFBQVA7QUFDRCIsImZpbGUiOiJjcmVhdGUtYmV6aWVyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgQmV6aWVyIGZ1bmN0aW9uIGdlbmVyYXRvclxuICAgIFxuICBHYcOrdGFuIFJlbmF1ZGVhdSdzIEJlemllckVhc2luZ1xuICBodHRwczovL2dpdGh1Yi5jb20vZ3JlL2Jlemllci1lYXNpbmcvYmxvYi9tYXN0ZXIvaW5kZXguanMgIFxuICBodHRwczovL2dpdGh1Yi5jb20vZ3JlL2Jlemllci1lYXNpbmcvYmxvYi9tYXN0ZXIvTElDRU5TRVxuICBZb3UncmUgYSBoZXJvXG4gIFxuICBVc2VcbiAgXG4gICAgdmFyIGVhc2VPdXQgPSBuZXcgQmV6aWVyKC4xNywuNjcsLjgzLC42NyksXG4gICAgICB4ID0gZWFzZU91dCgwLjUpOyAvLyByZXR1cm5zIDAuNjI3Li4uXG4qL1xuXG4vLyBDb25zdGFudHNcbmNvbnN0IE5FV1RPTl9JVEVSQVRJT05TID0gODtcbmNvbnN0IE5FV1RPTl9NSU5fU0xPUEUgPSAwLjAwMTtcbmNvbnN0IFNVQkRJVklTSU9OX1BSRUNJU0lPTiA9IDAuMDAwMDAwMTtcbmNvbnN0IFNVQkRJVklTSU9OX01BWF9JVEVSQVRJT05TID0gMTA7XG5jb25zdCBLX1NQTElORV9UQUJMRV9TSVpFID0gMTE7XG5jb25zdCBLX1NBTVBMRV9TVEVQX1NJWkUgPSAxLjAgLyAoS19TUExJTkVfVEFCTEVfU0laRSAtIDEuMCk7XG5jb25zdCBGTE9BVF8zMl9TVVBQT1JURUQgPSAodHlwZW9mIEZsb2F0MzJBcnJheSAhPT0gJ3VuZGVmaW5lZCcpO1xuXG4vLyBIZWxwZXIgbWV0aG9kc1xuY29uc3QgYSA9IChhMSwgYTIpID0+IDEuMCAtIDMuMCAqIGEyICsgMy4wICogYTE7XG5jb25zdCBiID0gKGExLCBhMikgPT4gMy4wICogYTIgLSA2LjAgKiBhMTtcbmNvbnN0IGMgPSAoYTEpID0+IDMuMCAqIGExO1xuXG5jb25zdCBnZXRTbG9wZSA9ICh0LCBhMSwgYTIpID0+IDMuMCAqIGEoYTEsIGEyKSAqIHQgKiB0ICsgMi4wICogYihhMSwgYTIpICogdCArIGMoYTEpO1xuXG5jb25zdCBjYWxjQmV6aWVyID0gKHQsIGExLCBhMikgPT4gKChhKGExLCBhMikgKiB0ICsgYihhMSwgYTIpKSAqIHQgKyBjKGExKSkgKiB0O1xuXG4vKlxuICBDcmVhdGUgYSBjdWJpYyBiZXppZXIgcmVzb2x2ZXJcbiovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjdWJpY0JlemllcihtWDEsIG1ZMSwgbVgyLCBtWTIpIHtcbiAgY29uc3Qgc2FtcGxlVmFsdWVzID0gRkxPQVRfMzJfU1VQUE9SVEVEID8gbmV3IEZsb2F0MzJBcnJheShLX1NQTElORV9UQUJMRV9TSVpFKSA6IG5ldyBBcnJheShLX1NQTElORV9UQUJMRV9TSVpFKTtcbiAgbGV0IF9wcmVjb21wdXRlZCA9IGZhbHNlO1xuXG4gIGNvbnN0IGJpbmFyeVN1YmRpdmlkZSA9IChhWCwgYUEsIGFCKSA9PiB7XG4gICAgbGV0IGkgPSAwO1xuICAgIGxldCBjdXJyZW50WDtcbiAgICBsZXQgY3VycmVudFQ7XG5cbiAgICBkbyB7XG4gICAgICBjdXJyZW50VCA9IGFBICsgKGFCIC0gYUEpIC8gMi4wO1xuICAgICAgY3VycmVudFggPSBjYWxjQmV6aWVyKGN1cnJlbnRULCBtWDEsIG1YMikgLSBhWDtcbiAgICAgIGlmIChjdXJyZW50WCA+IDAuMCkge1xuICAgICAgICBhQiA9IGN1cnJlbnRUO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYUEgPSBjdXJyZW50VDtcbiAgICAgIH1cbiAgICB9IHdoaWxlIChNYXRoLmFicyhjdXJyZW50WCkgPiBTVUJESVZJU0lPTl9QUkVDSVNJT04gJiYgKytpIDwgU1VCRElWSVNJT05fTUFYX0lURVJBVElPTlMpO1xuXG4gICAgcmV0dXJuIGN1cnJlbnRUO1xuICB9O1xuXG4gIGNvbnN0IG5ld3RvblJhcGhzb25JdGVyYXRlID0gKGFYLCBhR3Vlc3NUKSA9PiB7XG4gICAgbGV0IGkgPSAwO1xuICAgIGxldCBjdXJyZW50U2xvcGUgPSAwO1xuICAgIGxldCBjdXJyZW50WDtcblxuICAgIGZvciAoOyBpIDwgTkVXVE9OX0lURVJBVElPTlM7ICsraSkge1xuICAgICAgY3VycmVudFNsb3BlID0gZ2V0U2xvcGUoYUd1ZXNzVCwgbVgxLCBtWDIpO1xuICAgICAgXG4gICAgICBpZiAoY3VycmVudFNsb3BlID09PSAwLjApIHtcbiAgICAgICAgcmV0dXJuIGFHdWVzc1Q7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGN1cnJlbnRYID0gY2FsY0JlemllcihhR3Vlc3NULCBtWDEsIG1YMikgLSBhWDtcbiAgICAgIGFHdWVzc1QgLT0gY3VycmVudFggLyBjdXJyZW50U2xvcGU7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBhR3Vlc3NUO1xuICB9O1xuXG4gIGNvbnN0IGNhbGNTYW1wbGVWYWx1ZXMgPSAoKSA9PiB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBLX1NQTElORV9UQUJMRV9TSVpFOyArK2kpIHtcbiAgICAgIHNhbXBsZVZhbHVlc1tpXSA9IGNhbGNCZXppZXIoaSAqIEtfU0FNUExFX1NURVBfU0laRSwgbVgxLCBtWDIpO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBnZXRURm9yWCA9IChhWCkgPT4ge1xuICAgIGxldCBpbnRlcnZhbFN0YXJ0ID0gMC4wO1xuICAgIGxldCBjdXJyZW50U2FtcGxlID0gMTtcbiAgICBsZXQgbGFzdFNhbXBsZSA9IEtfU1BMSU5FX1RBQkxFX1NJWkUgLSAxO1xuICAgIGxldCBkaXN0ID0gMC4wO1xuICAgIGxldCBndWVzc0ZvclQgPSAwLjA7XG4gICAgbGV0IGluaXRpYWxTbG9wZSA9IDAuMDtcbiAgICAgIFxuICAgIGZvciAoOyBjdXJyZW50U2FtcGxlICE9IGxhc3RTYW1wbGUgJiYgc2FtcGxlVmFsdWVzW2N1cnJlbnRTYW1wbGVdIDw9IGFYOyArK2N1cnJlbnRTYW1wbGUpIHtcbiAgICAgIGludGVydmFsU3RhcnQgKz0gS19TQU1QTEVfU1RFUF9TSVpFO1xuICAgIH1cbiAgICBcbiAgICAtLWN1cnJlbnRTYW1wbGU7XG4gICAgXG4gICAgZGlzdCA9IChhWCAtIHNhbXBsZVZhbHVlc1tjdXJyZW50U2FtcGxlXSkgLyAoc2FtcGxlVmFsdWVzW2N1cnJlbnRTYW1wbGUrMV0gLSBzYW1wbGVWYWx1ZXNbY3VycmVudFNhbXBsZV0pO1xuICAgIGd1ZXNzRm9yVCA9IGludGVydmFsU3RhcnQgKyBkaXN0ICogS19TQU1QTEVfU1RFUF9TSVpFO1xuICAgIFxuICAgIGluaXRpYWxTbG9wZSA9IGdldFNsb3BlKGd1ZXNzRm9yVCwgbVgxLCBtWDIpO1xuICAgIFxuICAgIC8vIElmIHNsb3BlIGlzIGdyZWF0ZXIgdGhhbiBtaW5cbiAgICBpZiAoaW5pdGlhbFNsb3BlID49IE5FV1RPTl9NSU5fU0xPUEUpIHtcbiAgICAgIHJldHVybiBuZXd0b25SYXBoc29uSXRlcmF0ZShhWCwgZ3Vlc3NGb3JUKTtcbiAgICAvLyBTbG9wZSBpcyBlcXVhbCB0byBtaW5cbiAgICB9IGVsc2UgaWYgKGluaXRpYWxTbG9wZSA9PT0gMC4wKSB7XG4gICAgICByZXR1cm4gZ3Vlc3NGb3JUO1xuICAgIC8vIFNsb3BlIGlzIGxlc3MgdGhhbiBtaW5cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJpbmFyeVN1YmRpdmlkZShhWCwgaW50ZXJ2YWxTdGFydCwgaW50ZXJ2YWxTdGFydCArIEtfU0FNUExFX1NURVBfU0laRSk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IHByZWNvbXB1dGUgPSAoKSA9PiB7XG4gICAgX3ByZWNvbXB1dGVkID0gdHJ1ZTtcbiAgICBpZiAobVgxICE9IG1ZMSB8fCBtWDIgIT0gbVkyKSB7XG4gICAgICBjYWxjU2FtcGxlVmFsdWVzKCk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IHJlc29sdmVyID0gKGFYKSA9PiB7XG4gICAgbGV0IHJldHVyblZhbHVlO1xuXG4gICAgaWYgKCFfcHJlY29tcHV0ZWQpIHtcbiAgICAgIHByZWNvbXB1dGUoKTtcbiAgICB9XG4gICAgXG4gICAgLy8gSWYgbGluZWFyIGdyYWRpZW50LCByZXR1cm4gWCBhcyBUXG4gICAgaWYgKG1YMSA9PT0gbVkxICYmIG1YMiA9PT0gbVkyKSB7XG4gICAgICByZXR1cm5WYWx1ZSA9IGFYO1xuICAgICAgXG4gICAgLy8gSWYgYXQgc3RhcnQsIHJldHVybiAwXG4gICAgfSBlbHNlIGlmIChhWCA9PT0gMCkge1xuICAgICAgcmV0dXJuVmFsdWUgPSAwO1xuICAgICAgXG4gICAgLy8gSWYgYXQgZW5kLCByZXR1cm4gMVxuICAgIH0gZWxzZSBpZiAoYVggPT09IDEpIHtcbiAgICAgIHJldHVyblZhbHVlID0gMTtcblxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm5WYWx1ZSA9IGNhbGNCZXppZXIoZ2V0VEZvclgoYVgpLCBtWTEsIG1ZMik7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgfTtcblxuICByZXR1cm4gcmVzb2x2ZXI7XG59XG4iXX0=