'use strict';

exports.__esModule = true;
exports.default = cubicBezier;
/*
  Bezier function generator
    
  GaÃ«tan Renaudeau's BezierEasing
  https://github.com/gre/bezier-easing/blob/master/index.js  
  https://github.com/gre/bezier-easing/blob/master/LICENSE
  You're a hero
  
  Use
  
    var easeOut = new Bezier(.17,.67,.83,.67),
      x = easeOut(0.5); // returns 0.627...
*/

// Constants
var NEWTON_ITERATIONS = 8;
var NEWTON_MIN_SLOPE = 0.001;
var SUBDIVISION_PRECISION = 0.0000001;
var SUBDIVISION_MAX_ITERATIONS = 10;
var K_SPLINE_TABLE_SIZE = 11;
var K_SAMPLE_STEP_SIZE = 1.0 / (K_SPLINE_TABLE_SIZE - 1.0);
var FLOAT_32_SUPPORTED = typeof Float32Array !== 'undefined';

// Helper methods
var a = function (a1, a2) {
  return 1.0 - 3.0 * a2 + 3.0 * a1;
};
var b = function (a1, a2) {
  return 3.0 * a2 - 6.0 * a1;
};
var c = function (a1) {
  return 3.0 * a1;
};

var getSlope = function (t, a1, a2) {
  return 3.0 * a(a1, a2) * t * t + 2.0 * b(a1, a2) * t + c(a1);
};

var calcBezier = function (t, a1, a2) {
  return ((a(a1, a2) * t + b(a1, a2)) * t + c(a1)) * t;
};

/*
  Create a cubic bezier resolver
*/
function cubicBezier(mX1, mY1, mX2, mY2) {
  var sampleValues = FLOAT_32_SUPPORTED ? new Float32Array(K_SPLINE_TABLE_SIZE) : new Array(K_SPLINE_TABLE_SIZE);
  var _precomputed = false;

  var binarySubdivide = function (aX, aA, aB) {
    var i = 0;
    var currentX = void 0;
    var currentT = void 0;

    do {
      currentT = aA + (aB - aA) / 2.0;
      currentX = calcBezier(currentT, mX1, mX2) - aX;
      if (currentX > 0.0) {
        aB = currentT;
      } else {
        aA = currentT;
      }
    } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);

    return currentT;
  };

  var newtonRaphsonIterate = function (aX, aGuessT) {
    var i = 0;
    var currentSlope = 0;
    var currentX = void 0;

    for (; i < NEWTON_ITERATIONS; ++i) {
      currentSlope = getSlope(aGuessT, mX1, mX2);

      if (currentSlope === 0.0) {
        return aGuessT;
      }

      currentX = calcBezier(aGuessT, mX1, mX2) - aX;
      aGuessT -= currentX / currentSlope;
    }

    return aGuessT;
  };

  var calcSampleValues = function () {
    for (var i = 0; i < K_SPLINE_TABLE_SIZE; ++i) {
      sampleValues[i] = calcBezier(i * K_SAMPLE_STEP_SIZE, mX1, mX2);
    }
  };

  var getTForX = function (aX) {
    var intervalStart = 0.0;
    var currentSample = 1;
    var lastSample = K_SPLINE_TABLE_SIZE - 1;
    var dist = 0.0;
    var guessForT = 0.0;
    var initialSlope = 0.0;

    for (; currentSample != lastSample && sampleValues[currentSample] <= aX; ++currentSample) {
      intervalStart += K_SAMPLE_STEP_SIZE;
    }

    --currentSample;

    dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);
    guessForT = intervalStart + dist * K_SAMPLE_STEP_SIZE;

    initialSlope = getSlope(guessForT, mX1, mX2);

    // If slope is greater than min
    if (initialSlope >= NEWTON_MIN_SLOPE) {
      return newtonRaphsonIterate(aX, guessForT);
      // Slope is equal to min
    } else if (initialSlope === 0.0) {
      return guessForT;
      // Slope is less than min
    } else {
      return binarySubdivide(aX, intervalStart, intervalStart + K_SAMPLE_STEP_SIZE);
    }
  };

  var precompute = function () {
    _precomputed = true;
    if (mX1 != mY1 || mX2 != mY2) {
      calcSampleValues();
    }
  };

  var resolver = function (aX) {
    var returnValue = void 0;

    if (!_precomputed) {
      precompute();
    }

    // If linear gradient, return X as T
    if (mX1 === mY1 && mX2 === mY2) {
      returnValue = aX;

      // If at start, return 0
    } else if (aX === 0) {
      returnValue = 0;

      // If at end, return 1
    } else if (aX === 1) {
      returnValue = 1;
    } else {
      returnValue = calcBezier(getTForX(aX), mY1, mY2);
    }

    return returnValue;
  };

  return resolver;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9lYXNpbmcvY3ViaWMtYmV6aWVyLmpzIl0sIm5hbWVzIjpbImN1YmljQmV6aWVyIiwiTkVXVE9OX0lURVJBVElPTlMiLCJORVdUT05fTUlOX1NMT1BFIiwiU1VCRElWSVNJT05fUFJFQ0lTSU9OIiwiU1VCRElWSVNJT05fTUFYX0lURVJBVElPTlMiLCJLX1NQTElORV9UQUJMRV9TSVpFIiwiS19TQU1QTEVfU1RFUF9TSVpFIiwiRkxPQVRfMzJfU1VQUE9SVEVEIiwiRmxvYXQzMkFycmF5IiwiYSIsImExIiwiYTIiLCJiIiwiYyIsImdldFNsb3BlIiwidCIsImNhbGNCZXppZXIiLCJtWDEiLCJtWTEiLCJtWDIiLCJtWTIiLCJzYW1wbGVWYWx1ZXMiLCJBcnJheSIsIl9wcmVjb21wdXRlZCIsImJpbmFyeVN1YmRpdmlkZSIsImFYIiwiYUEiLCJhQiIsImkiLCJjdXJyZW50WCIsImN1cnJlbnRUIiwiTWF0aCIsImFicyIsIm5ld3RvblJhcGhzb25JdGVyYXRlIiwiYUd1ZXNzVCIsImN1cnJlbnRTbG9wZSIsImNhbGNTYW1wbGVWYWx1ZXMiLCJnZXRURm9yWCIsImludGVydmFsU3RhcnQiLCJjdXJyZW50U2FtcGxlIiwibGFzdFNhbXBsZSIsImRpc3QiLCJndWVzc0ZvclQiLCJpbml0aWFsU2xvcGUiLCJwcmVjb21wdXRlIiwicmVzb2x2ZXIiLCJyZXR1cm5WYWx1ZSJdLCJtYXBwaW5ncyI6Ijs7O2tCQW1Dd0JBLFc7QUFuQ3hCOzs7Ozs7Ozs7Ozs7OztBQWNBO0FBQ0EsSUFBTUMsb0JBQW9CLENBQTFCO0FBQ0EsSUFBTUMsbUJBQW1CLEtBQXpCO0FBQ0EsSUFBTUMsd0JBQXdCLFNBQTlCO0FBQ0EsSUFBTUMsNkJBQTZCLEVBQW5DO0FBQ0EsSUFBTUMsc0JBQXNCLEVBQTVCO0FBQ0EsSUFBTUMscUJBQXFCLE9BQU9ELHNCQUFzQixHQUE3QixDQUEzQjtBQUNBLElBQU1FLHFCQUFzQixPQUFPQyxZQUFQLEtBQXdCLFdBQXBEOztBQUVBO0FBQ0Es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QmdCO0FBQ0Q7QUFDRixHQUxEOztBQU9BLE1BQU1TLFdBQVcsVUFBQ3BCLEVBQUQsRUFBUTtBQUN2QixRQUFJcUIsb0JBQUo7O0FBRUEsUUFBSSxDQUFDdkIsWUFBTCxFQUFtQjtBQUNqQnFCO0FBQ0Q7O0FBRUQ7QUFDQSxRQUFJM0IsUUFBUUMsR0FBUixJQUFlQyxRQUFRQyxHQUEzQixFQUFnQztBQUM5QjBCLG9CQUFjckIsRUFBZDs7QUFFRjtBQUNDLEtBSkQsTUFJTyxJQUFJQSxPQUFPLENBQVgsRUFBYztBQUNuQnFCLG9CQUFjLENBQWQ7O0FBRUY7QUFDQyxLQUpNLE1BSUEsSUFBSXJCLE9BQU8sQ0FBWCxFQUFjO0FBQ25CcUIsb0JBQWMsQ0FBZDtBQUVELEtBSE0sTUFHQTtBQUNMQSxvQkFBYzlCLFdBQVdxQixTQUFTWixFQUFULENBQVgsRUFBeUJQLEdBQXpCLEVBQThCRSxHQUE5QixDQUFkO0FBQ0Q7O0FBRUQsV0FBTzBCLFdBQVA7QUFDRCxHQXhCRDs7QUEwQkEsU0FBT0QsUUFBUDtBQUNEIiwiZmlsZSI6ImN1YmljLWJlemllci5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG4gIEJlemllciBmdW5jdGlvbiBnZW5lcmF0b3JcbiAgICBcbiAgR2HDq3RhbiBSZW5hdWRlYXUncyBCZXppZXJFYXNpbmdcbiAgaHR0cHM6Ly9naXRodWIuY29tL2dyZS9iZXppZXItZWFzaW5nL2Jsb2IvbWFzdGVyL2luZGV4LmpzICBcbiAgaHR0cHM6Ly9naXRodWIuY29tL2dyZS9iZXppZXItZWFzaW5nL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcbiAgWW91J3JlIGEgaGVyb1xuICBcbiAgVXNlXG4gIFxuICAgIHZhciBlYXNlT3V0ID0gbmV3IEJlemllciguMTcsLjY3LC44MywuNjcpLFxuICAgICAgeCA9IGVhc2VPdXQoMC41KTsgLy8gcmV0dXJucyAwLjYyNy4uLlxuKi9cblxuLy8gQ29uc3RhbnRzXG5jb25zdCBORVdUT05fSVRFUkFUSU9OUyA9IDg7XG5jb25zdCBORVdUT05fTUlOX1NMT1BFID0gMC4wMDE7XG5jb25zdCBTVUJESVZJU0lPTl9QUkVDSVNJT04gPSAwLjAwMDAwMDE7XG5jb25zdCBTVUJESVZJU0lPTl9NQVhfSVRFUkFUSU9OUyA9IDEwO1xuY29uc3QgS19TUExJTkVfVEFCTEVfU0laRSA9IDExO1xuY29uc3QgS19TQU1QTEVfU1RFUF9TSVpFID0gMS4wIC8gKEtfU1BMSU5FX1RBQkxFX1NJWkUgLSAxLjApO1xuY29uc3QgRkxPQVRfMzJfU1VQUE9SVEVEID0gKHR5cGVvZiBGbG9hdDMyQXJyYXkgIT09ICd1bmRlZmluZWQnKTtcblxuLy8gSGVscGVyIG1ldGhvZHNcbmNvbnN0IGEgPSAoYTEsIGEyKSA9PiAxLjAgLSAzLjAgKiBhMiArIDMuMCAqIGExO1xuY29uc3QgYiA9IChhMSwgYTIpID0+IDMuMCAqIGEyIC0gNi4wICogYTE7XG5jb25zdCBjID0gKGExKSA9PiAzLjAgKiBhMTtcblxuY29uc3QgZ2V0U2xvcGUgPSAodCwgYTEsIGEyKSA9PiAzLjAgKiBhKGExLCBhMikgKiB0ICogdCArIDIuMCAqIGIoYTEsIGEyKSAqIHQgKyBjKGExKTtcblxuY29uc3QgY2FsY0JlemllciA9ICh0LCBhMSwgYTIpID0+ICgoYShhMSwgYTIpICogdCArIGIoYTEsIGEyKSkgKiB0ICsgYyhhMSkpICogdDtcblxuLypcbiAgQ3JlYXRlIGEgY3ViaWMgYmV6aWVyIHJlc29sdmVyXG4qL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY3ViaWNCZXppZXIobVgxLCBtWTEsIG1YMiwgbVkyKSB7XG4gIGNvbnN0IHNhbXBsZVZhbHVlcyA9IEZMT0FUXzMyX1NVUFBPUlRFRCA/IG5ldyBGbG9hdDMyQXJyYXkoS19TUExJTkVfVEFCTEVfU0laRSkgOiBuZXcgQXJyYXkoS19TUExJTkVfVEFCTEVfU0laRSk7XG4gIGxldCBfcHJlY29tcHV0ZWQgPSBmYWxzZTtcblxuICBjb25zdCBiaW5hcnlTdWJkaXZpZGUgPSAoYVgsIGFBLCBhQikgPT4ge1xuICAgIGxldCBpID0gMDtcbiAgICBsZXQgY3VycmVudFg7XG4gICAgbGV0IGN1cnJlbnRUO1xuXG4gICAgZG8ge1xuICAgICAgY3VycmVudFQgPSBhQSArIChhQiAtIGFBKSAvIDIuMDtcbiAgICAgIGN1cnJlbnRYID0gY2FsY0JlemllcihjdXJyZW50VCwgbVgxLCBtWDIpIC0gYVg7XG4gICAgICBpZiAoY3VycmVudFggPiAwLjApIHtcbiAgICAgICAgYUIgPSBjdXJyZW50VDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFBID0gY3VycmVudFQ7XG4gICAgICB9XG4gICAgfSB3aGlsZSAoTWF0aC5hYnMoY3VycmVudFgpID4gU1VCRElWSVNJT05fUFJFQ0lTSU9OICYmICsraSA8IFNVQkRJVklTSU9OX01BWF9JVEVSQVRJT05TKTtcblxuICAgIHJldHVybiBjdXJyZW50VDtcbiAgfTtcblxuICBjb25zdCBuZXd0b25SYXBoc29uSXRlcmF0ZSA9IChhWCwgYUd1ZXNzVCkgPT4ge1xuICAgIGxldCBpID0gMDtcbiAgICBsZXQgY3VycmVudFNsb3BlID0gMDtcbiAgICBsZXQgY3VycmVudFg7XG5cbiAgICBmb3IgKDsgaSA8IE5FV1RPTl9JVEVSQVRJT05TOyArK2kpIHtcbiAgICAgIGN1cnJlbnRTbG9wZSA9IGdldFNsb3BlKGFHdWVzc1QsIG1YMSwgbVgyKTtcbiAgICAgIFxuICAgICAgaWYgKGN1cnJlbnRTbG9wZSA9PT0gMC4wKSB7XG4gICAgICAgIHJldHVybiBhR3Vlc3NUO1xuICAgICAgfVxuICAgICAgXG4gICAgICBjdXJyZW50WCA9IGNhbGNCZXppZXIoYUd1ZXNzVCwgbVgxLCBtWDIpIC0gYVg7XG4gICAgICBhR3Vlc3NUIC09IGN1cnJlbnRYIC8gY3VycmVudFNsb3BlO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gYUd1ZXNzVDtcbiAgfTtcblxuICBjb25zdCBjYWxjU2FtcGxlVmFsdWVzID0gKCkgPT4ge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgS19TUExJTkVfVEFCTEVfU0laRTsgKytpKSB7XG4gICAgICBzYW1wbGVWYWx1ZXNbaV0gPSBjYWxjQmV6aWVyKGkgKiBLX1NBTVBMRV9TVEVQX1NJWkUsIG1YMSwgbVgyKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgZ2V0VEZvclggPSAoYVgpID0+IHtcbiAgICBsZXQgaW50ZXJ2YWxTdGFydCA9IDAuMDtcbiAgICBsZXQgY3VycmVudFNhbXBsZSA9IDE7XG4gICAgbGV0IGxhc3RTYW1wbGUgPSBLX1NQTElORV9UQUJMRV9TSVpFIC0gMTtcbiAgICBsZXQgZGlzdCA9IDAuMDtcbiAgICBsZXQgZ3Vlc3NGb3JUID0gMC4wO1xuICAgIGxldCBpbml0aWFsU2xvcGUgPSAwLjA7XG4gICAgICBcbiAgICBmb3IgKDsgY3VycmVudFNhbXBsZSAhPSBsYXN0U2FtcGxlICYmIHNhbXBsZVZhbHVlc1tjdXJyZW50U2FtcGxlXSA8PSBhWDsgKytjdXJyZW50U2FtcGxlKSB7XG4gICAgICBpbnRlcnZhbFN0YXJ0ICs9IEtfU0FNUExFX1NURVBfU0laRTtcbiAgICB9XG4gICAgXG4gICAgLS1jdXJyZW50U2FtcGxlO1xuICAgIFxuICAgIGRpc3QgPSAoYVggLSBzYW1wbGVWYWx1ZXNbY3VycmVudFNhbXBsZV0pIC8gKHNhbXBsZVZhbHVlc1tjdXJyZW50U2FtcGxlKzFdIC0gc2FtcGxlVmFsdWVzW2N1cnJlbnRTYW1wbGVdKTtcbiAgICBndWVzc0ZvclQgPSBpbnRlcnZhbFN0YXJ0ICsgZGlzdCAqIEtfU0FNUExFX1NURVBfU0laRTtcbiAgICBcbiAgICBpbml0aWFsU2xvcGUgPSBnZXRTbG9wZShndWVzc0ZvclQsIG1YMSwgbVgyKTtcbiAgICBcbiAgICAvLyBJZiBzbG9wZSBpcyBncmVhdGVyIHRoYW4gbWluXG4gICAgaWYgKGluaXRpYWxTbG9wZSA+PSBORVdUT05fTUlOX1NMT1BFKSB7XG4gICAgICByZXR1cm4gbmV3dG9uUmFwaHNvbkl0ZXJhdGUoYVgsIGd1ZXNzRm9yVCk7XG4gICAgLy8gU2xvcGUgaXMgZXF1YWwgdG8gbWluXG4gICAgfSBlbHNlIGlmIChpbml0aWFsU2xvcGUgPT09IDAuMCkge1xuICAgICAgcmV0dXJuIGd1ZXNzRm9yVDtcbiAgICAvLyBTbG9wZSBpcyBsZXNzIHRoYW4gbWluXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBiaW5hcnlTdWJkaXZpZGUoYVgsIGludGVydmFsU3RhcnQsIGludGVydmFsU3RhcnQgKyBLX1NBTVBMRV9TVEVQX1NJWkUpO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBwcmVjb21wdXRlID0gKCkgPT4ge1xuICAgIF9wcmVjb21wdXRlZCA9IHRydWU7XG4gICAgaWYgKG1YMSAhPSBtWTEgfHwgbVgyICE9IG1ZMikge1xuICAgICAgY2FsY1NhbXBsZVZhbHVlcygpO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCByZXNvbHZlciA9IChhWCkgPT4ge1xuICAgIGxldCByZXR1cm5WYWx1ZTtcblxuICAgIGlmICghX3ByZWNvbXB1dGVkKSB7XG4gICAgICBwcmVjb21wdXRlKCk7XG4gICAgfVxuICAgIFxuICAgIC8vIElmIGxpbmVhciBncmFkaWVudCwgcmV0dXJuIFggYXMgVFxuICAgIGlmIChtWDEgPT09IG1ZMSAmJiBtWDIgPT09IG1ZMikge1xuICAgICAgcmV0dXJuVmFsdWUgPSBhWDtcbiAgICAgIFxuICAgIC8vIElmIGF0IHN0YXJ0LCByZXR1cm4gMFxuICAgIH0gZWxzZSBpZiAoYVggPT09IDApIHtcbiAgICAgIHJldHVyblZhbHVlID0gMDtcbiAgICAgIFxuICAgIC8vIElmIGF0IGVuZCwgcmV0dXJuIDFcbiAgICB9IGVsc2UgaWYgKGFYID09PSAxKSB7XG4gICAgICByZXR1cm5WYWx1ZSA9IDE7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuVmFsdWUgPSBjYWxjQmV6aWVyKGdldFRGb3JYKGFYKSwgbVkxLCBtWTIpO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gIH07XG5cbiAgcmV0dXJuIHJlc29sdmVyO1xufVxuIl19