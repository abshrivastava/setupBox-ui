'use strict';

exports.__esModule = true;
exports.steps = exports.clamp = exports.clampOver = exports.clampUnder = exports.interpolate = exports.flow = exports.appendUnit = undefined;

var _calc = require('./calc');

/**
 * Append Unit
 * Creates a function that will append the unit to a given value
 * appendUnit('px')(20) -> '20px'
 * @param  {string} unit)
 * @return {number}
 */
var appendUnit = exports.appendUnit = function (unit) {
  return function (v) {
    return '' + v + unit;
  };
};

/**
 * Flow
 * Compose other transformers to run linearily
 * flow(min(20), max(40))
 * @param  {...functions} transformers
 * @return {function}
 */
var flow = exports.flow = function () {
  for (var _len = arguments.length, transformers = Array(_len), _key = 0; _key < _len; _key++) {
    transformers[_key] = arguments[_key];
  }

  var numTransformers = transformers.length;
  var i = 0;

  return function (v) {
    for (i = 0; i < numTransformers; i++) {
      v = transformers[i](v);
    }

    return v;
  };
};

var interpolate = exports.interpolate = function (input, output, rangeEasing) {
  var rangeLength = input.length;
  var finalIndex = rangeLength - 1;

  return function (v) {
    // If value outside minimum range, quickly return
    if (v <= input[0]) {
      return output[0];
    }

    // If value outside maximum range, quickly return
    if (v >= input[finalIndex]) {
      return output[finalIndex];
    }

    var i = 0;

    // Find index of range start
    for (; i < rangeLength; i++) {
      if (input[i] > v || i === finalIndex) {
        break;
      }
    }

    var progressInRange = (0, _calc.getProgressFromValue)(input[i], input[i + 1], v);
    var easedProgress = rangeEasing ? rangeEasing[i](progressInRange) : progressInRange;
    return (0, _calc.getValueFromProgress)(output[i], output[i + 1], easedProgress);
  };
};

/**
 * Clamp value between
 * Creates a function that will restrict a given value between `min` and `max`
 * @param  {number} min
 * @param  {number} max
 * @return {number}
 */
var clampUnder = exports.clampUnder = function (max) {
  return function (v) {
    return Math.min(v, max);
  };
};
var clampOver = exports.clampOver = function (min) {
  return function (v) {
    return Math.max(v, min);
  };
};
var clamp = exports.clamp = function (min, max) {
  return flow(clampOver(min), clampUnder(max));
};

var steps = exports.steps = function (steps, min, max) {
  return function (v) {
    var progress = (0, _calc.getProgressFromValue)(min, max, v);
    return (0, _calc.stepProgress)(steps, progress);
  };
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9pbmMvZmlsdGVycy5qcyJdLCJuYW1lcyI6WyJhcHBlbmRVbml0IiwidW5pdCIsInYiLCJmbG93IiwidHJhbnNmb3JtZXJzIiwibnVtVHJhbnNmb3JtZXJzIiwibGVuZ3RoIiwiaSIsImludGVycG9sYXRlIiwiaW5wdXQiLCJvdXRwdXQiLCJyYW5nZUVhc2luZyIsInJhbmdlTGVuZ3RoIiwiZmluYWxJbmRleCIsInByb2dyZXNzSW5SYW5nZSIsImVhc2VkUHJvZ3Jlc3MiLCJjbGFtcFVuZGVyIiwibWF4IiwiTWF0aCIsIm1pbiIsImNsYW1wT3ZlciIsImNsYW1wIiwic3RlcHMiLCJwcm9ncmVzcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTs7QUFFQTs7Ozs7OztBQU9PLElBQU1BLGtDQUFhLFVBQUNDLElBQUQ7QUFBQSxTQUFVLFVBQUNDLENBQUQ7QUFBQSxnQkFBVUEsQ0FBVixHQUFjRCxJQUFkO0FBQUEsR0FBVjtBQUFBLENBQW5COztBQUVQOzs7Ozs7O0FBT08sSUFBTUUsc0JBQU8sWUFBcUI7QUFBQSxvQ0FBakJDLFlBQWlCO0FBQWpCQSxnQkFBaUI7QUFBQTs7QUFDdkMsTUFBTUMsa0JBQWtCRCxhQUFhRSxNQUFyQztBQUNBLE1BQUlDLElBQUksQ0FBUjs7QUFFQSxTQUFPLFVBQUNMLENBQUQsRUFBTztBQUNaLFNBQUtLLElBQUksQ0FBVCxFQUFZQSxJQUFJRixlQUFoQixFQUFpQ0UsR0FBakMsRUFBc0M7QUFDcENMLFVBQUlFLGFBQWFHLENBQWIsRUFBZ0JMLENBQWhCLENBQUo7QUFDRDs7QUFFRCxXQUFPQSxDQUFQO0FBQ0QsR0FORDtBQU9ELENBWE07O0FBYUEsSUFBTU0sb0NBQWMsVUFBQ0MsS0FBRCxFQUFRQyxNQUFSLEVBQWdCQyxXQUFoQixFQUFnQztBQUN6RCxNQUFNQyxjQUFjSCxNQUFNSCxNQUExQjtBQUNBLE1BQU1PLGFBQWFELGNBQWMsQ0FBakM7O0FBRUEsU0FBTyxVQUFDVixDQUFELEVBQU87QUFDWjtBQUNBLFFBQUlBLEtBQUtPLE1BQU0sQ0FBTixDQUFULEVBQW1CO0FBQ2pCLGFBQU9DLE9BQU8sQ0FBUCxDQUFQO0FBQ0Q7O0FBRUQ7QUFDQSxRQUFJUixLQUFLTyxNQUFNSSxVQUFOLENBQVQsRUFBNEI7QUFDMUIsYUFBT0gsT0FBT0csVUFBUCxDQUFQO0FBQ0Q7O0FBRUQsUUFBSU4sSUFBSSxDQUFSOztBQUVBO0FBQ0EsV0FBT0EsSUFBSUssV0FBWCxFQUF3QkwsR0FBeEIsRUFBNkI7QUFDM0IsVUFBSUUsTUFBTUYsQ0FBTixJQUFXTCxDQUFYLElBQWdCSyxNQUFNTSxVQUExQixFQUFzQztBQUNwQztBQUNEO0FBQ0Y7O0FBRUQsUUFBTUMsa0JBQWtCLGdDQUFxQkwsTUFBTUYsQ0FBTixDQUFyQixFQUErQkUsTUFBTUYsSUFBSSxDQUFWLENBQS9CLEVBQTZDTCxDQUE3QyxDQUF4QjtBQUNBLFFBQU1hLGdCQUFpQkosV0FBRCxHQUFnQkEsWUFBWUosQ0FBWixFQUFlTyxlQUFmLENBQWhCLEdBQWtEQSxlQUF4RTtBQUNBLFdBQU8sZ0NBQXFCSixPQUFPSCxDQUFQLENBQXJCLEVBQWdDRyxPQUFPSCxJQUFJLENBQVgsQ0FBaEMsRUFBK0NRLGFBQS9DLENBQVA7QUFDRCxHQXZCRDtBQXdCRCxDQTVCTTs7QUE4QlA7Ozs7Ozs7QUFPTyxJQUFNQyxrQ0FBYSxVQUFDQyxHQUFEO0FBQUEsU0FBUyxVQUFDZixDQUFEO0FBQUEsV0FBT2dCLEtBQUtDLEdBQUwsQ0FBU2pCLENBQVQsRUFBWWUsR0FBWixDQUFQO0FBQUEsR0FBVDtBQUFBLENBQW5CO0FBQ0EsSUFBTUcsZ0NBQVksVUFBQ0QsR0FBRDtBQUFBLFNBQVMsVUFBQ2pCLENBQUQ7QUFBQSxXQUFPZ0IsS0FBS0QsR0FBTCxDQUFTZixDQUFULEVBQVlpQixHQUFaLENBQVA7QUFBQSxHQUFUO0FBQUEsQ0FBbEI7QUFDQSxJQUFNRSx3QkFBUSxVQUFDRixHQUFELEVBQU1GLEdBQU47QUFBQSxTQUFjZCxLQUFLaUIsVUFBVUQsR0FBVixDQUFMLEVBQXFCSCxXQUFXQyxHQUFYLENBQXJCLENBQWQ7QUFBQSxDQUFkOztBQUVBLElBQU1LLHdCQUFRLFVBQUNBLEtBQUQsRUFBUUgsR0FBUixFQUFhRixHQUFiO0FBQUEsU0FBcUIsVUFBQ2YsQ0FBRCxFQUFPO0FBQy9DLFFBQU1xQixXQUFXLGdDQUFxQkosR0FBckIsRUFBMEJGLEdBQTFCLEVBQStCZixDQUEvQixDQUFqQjtBQUNBLFdBQU8sd0JBQWFvQixLQUFiLEVBQW9CQyxRQUFwQixDQUFQO0FBQ0QsR0FIb0I7QUFBQSxDQUFkIiwiZmlsZSI6ImZpbHRlcnMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnZXRQcm9ncmVzc0Zyb21WYWx1ZSwgZ2V0VmFsdWVGcm9tUHJvZ3Jlc3MsIHN0ZXBQcm9ncmVzcyB9IGZyb20gJy4vY2FsYyc7XG5cbi8qKlxuICogQXBwZW5kIFVuaXRcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgYXBwZW5kIHRoZSB1bml0IHRvIGEgZ2l2ZW4gdmFsdWVcbiAqIGFwcGVuZFVuaXQoJ3B4JykoMjApIC0+ICcyMHB4J1xuICogQHBhcmFtICB7c3RyaW5nfSB1bml0KVxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgYXBwZW5kVW5pdCA9ICh1bml0KSA9PiAodikgPT4gYCR7dn0ke3VuaXR9YDtcblxuLyoqXG4gKiBGbG93XG4gKiBDb21wb3NlIG90aGVyIHRyYW5zZm9ybWVycyB0byBydW4gbGluZWFyaWx5XG4gKiBmbG93KG1pbigyMCksIG1heCg0MCkpXG4gKiBAcGFyYW0gIHsuLi5mdW5jdGlvbnN9IHRyYW5zZm9ybWVyc1xuICogQHJldHVybiB7ZnVuY3Rpb259XG4gKi9cbmV4cG9ydCBjb25zdCBmbG93ID0gKC4uLnRyYW5zZm9ybWVycykgPT4ge1xuICBjb25zdCBudW1UcmFuc2Zvcm1lcnMgPSB0cmFuc2Zvcm1lcnMubGVuZ3RoO1xuICBsZXQgaSA9IDA7XG5cbiAgcmV0dXJuICh2KSA9PiB7XG4gICAgZm9yIChpID0gMDsgaSA8IG51bVRyYW5zZm9ybWVyczsgaSsrKSB7XG4gICAgICB2ID0gdHJhbnNmb3JtZXJzW2ldKHYpO1xuICAgIH1cblxuICAgIHJldHVybiB2O1xuICB9O1xufTtcblxuZXhwb3J0IGNvbnN0IGludGVycG9sYXRlID0gKGlucHV0LCBvdXRwdXQsIHJhbmdlRWFzaW5nKSA9PiB7XG4gIGNvbnN0IHJhbmdlTGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuICBjb25zdCBmaW5hbEluZGV4ID0gcmFuZ2VMZW5ndGggLSAxO1xuXG4gIHJldHVybiAodikgPT4ge1xuICAgIC8vIElmIHZhbHVlIG91dHNpZGUgbWluaW11bSByYW5nZSwgcXVpY2tseSByZXR1cm5cbiAgICBpZiAodiA8PSBpbnB1dFswXSkge1xuICAgICAgcmV0dXJuIG91dHB1dFswXTtcbiAgICB9XG5cbiAgICAvLyBJZiB2YWx1ZSBvdXRzaWRlIG1heGltdW0gcmFuZ2UsIHF1aWNrbHkgcmV0dXJuXG4gICAgaWYgKHYgPj0gaW5wdXRbZmluYWxJbmRleF0pIHtcbiAgICAgIHJldHVybiBvdXRwdXRbZmluYWxJbmRleF07XG4gICAgfVxuXG4gICAgbGV0IGkgPSAwO1xuXG4gICAgLy8gRmluZCBpbmRleCBvZiByYW5nZSBzdGFydFxuICAgIGZvciAoOyBpIDwgcmFuZ2VMZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGlucHV0W2ldID4gdiB8fCBpID09PSBmaW5hbEluZGV4KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHByb2dyZXNzSW5SYW5nZSA9IGdldFByb2dyZXNzRnJvbVZhbHVlKGlucHV0W2ldLCBpbnB1dFtpICsgMV0sIHYpO1xuICAgIGNvbnN0IGVhc2VkUHJvZ3Jlc3MgPSAocmFuZ2VFYXNpbmcpID8gcmFuZ2VFYXNpbmdbaV0ocHJvZ3Jlc3NJblJhbmdlKSA6IHByb2dyZXNzSW5SYW5nZTtcbiAgICByZXR1cm4gZ2V0VmFsdWVGcm9tUHJvZ3Jlc3Mob3V0cHV0W2ldLCBvdXRwdXRbaSArIDFdLCBlYXNlZFByb2dyZXNzKTtcbiAgfTtcbn07XG5cbi8qKlxuICogQ2xhbXAgdmFsdWUgYmV0d2VlblxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCByZXN0cmljdCBhIGdpdmVuIHZhbHVlIGJldHdlZW4gYG1pbmAgYW5kIGBtYXhgXG4gKiBAcGFyYW0gIHtudW1iZXJ9IG1pblxuICogQHBhcmFtICB7bnVtYmVyfSBtYXhcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IGNsYW1wVW5kZXIgPSAobWF4KSA9PiAodikgPT4gTWF0aC5taW4odiwgbWF4KTtcbmV4cG9ydCBjb25zdCBjbGFtcE92ZXIgPSAobWluKSA9PiAodikgPT4gTWF0aC5tYXgodiwgbWluKTtcbmV4cG9ydCBjb25zdCBjbGFtcCA9IChtaW4sIG1heCkgPT4gZmxvdyhjbGFtcE92ZXIobWluKSwgY2xhbXBVbmRlcihtYXgpKTtcblxuZXhwb3J0IGNvbnN0IHN0ZXBzID0gKHN0ZXBzLCBtaW4sIG1heCkgPT4gKHYpID0+IHtcbiAgY29uc3QgcHJvZ3Jlc3MgPSBnZXRQcm9ncmVzc0Zyb21WYWx1ZShtaW4sIG1heCwgdik7XG4gIHJldHVybiBzdGVwUHJvZ3Jlc3Moc3RlcHMsIHByb2dyZXNzKTtcbn07XG5cbiJdfQ==