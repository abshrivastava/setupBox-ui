'use strict';

exports.__esModule = true;
exports.stepProgress = exports.speedPerSecond = exports.speedPerFrame = exports.smooth = exports.restrict = exports.relativeValue = exports.random = exports.radiansToDegrees = exports.pointFromAngleAndDistance = exports.offset = exports.getProgressFromValue = exports.getValueFromProgress = exports.hypotenuse = exports.ease = exports.distance = exports.dilate = exports.degreesToRadians = exports.angle = undefined;

var _utils = require('./utils');

var ZERO_POINT = {
  x: 0,
  y: 0,
  z: 0
};

var distance1D = function (a, b) {
  return Math.abs(a - b);
};

/*
  Angle between points
  
  Translates the hypothetical line so that the 'from' coordinates
  are at 0,0
  
  @param [object]: X and Y coordinates of from point
  @param [object]: X and Y cordinates of to point
  @return [radian]: Angle between the two points in radians
*/
var angle = exports.angle = function (a) {
  var b = arguments.length <= 1 || arguments[1] === undefined ? ZERO_POINT : arguments[1];
  return radiansToDegrees(Math.atan2(a.x - b.x, a.y - b.y));
};

/*
  Convert degrees to radians
  
  @param [number]: Value in degrees
  @return [number]: Value in radians
*/
var degreesToRadians = exports.degreesToRadians = function (degrees) {
  return degrees * Math.PI / 180;
};

/*
  Dilate
  
  Change the progression between a and b according to dilation.
  
  So dilation = 0.5 would change
  
  a --------- b
  
  to
  
  a ---- b
  
  @param [number]: Previous value
  @param [number]: Current value
  @param [number]: Dilate progress by x
  @return [number]: Previous value plus the dilated difference
*/
var dilate = exports.dilate = function (a, b, dilation) {
  return a + (b - a) * dilation;
};

/*
  Distance
  
  Returns the distance between two n dimensional points.
  
  @param [object/number]: x and y or just x of point A
  @param [object/number]: (optional): x and y or just x of point B
  @return [number]: The distance between the two points
*/
var distance = exports.distance = function (a) {
  var b = arguments.length <= 1 || arguments[1] === undefined ? ZERO_POINT : arguments[1];

  // 1D dimensions
  if ((0, _utils.isNum)(a)) {
    return distance1D(a, b);

    // Multi-dimensional
  } else {
    var xDelta = distance1D(a.x, b.x);
    var yDelta = distance1D(a.y, b.y);
    var zDelta = (0, _utils.isNum)(a.z) ? distance1D(a.z, b.z) : 0;

    return Math.sqrt(Math.pow(xDelta, 2) + Math.pow(yDelta, 2) + Math.pow(zDelta, 2));
  }
};

/*
  Ease value within ranged parameters
  
  @param [number]: Progress between 0 and 1
  @param [number]: Value of 0 progress
  @param [number]: Value of 1 progress
  @param [string || function]: Name of preset easing
    to use or generated easing function
  @return [number]: Value of eased progress in range
*/
var ease = exports.ease = function (progress, from, to, ease) {
  var progressLimited = restrict(progress, 0, 1);
  var easedProgress = ease(progressLimited);

  return getValueFromProgress(easedProgress, from, to);
};

/*
  Hypotenuse
  
  Returns the hypotenuse, side C, given the lengths of sides A and B.
  
  @param [number]: Length of A
  @param [number]: Length of B
  @return [number]: Length of C
*/
var hypotenuse = exports.hypotenuse = function (a, b) {
  return Math.sqrt(a * a + b * b);
};

/*
  Value in range from progress
  
  Given a lower limit and an upper limit, we return the value within
  that range as expressed by progress (a number from 0-1)
  
  @param [number]: The progress between lower and upper limits expressed 0-1
  @param [number]: Lower limit of range
  @param [number]: Upper limit of range
  @return [number]: Value as calculated from progress within range (not limited within range)
*/
var getValueFromProgress = exports.getValueFromProgress = function (progress, from, to) {
  return -progress * from + progress * to + from;
};

/*
  Progress within given range
  
  Given a lower limit and an upper limit, we return the progress
  (expressed as a number 0-1) represented by the given value, and
  limit that progress to within 0-1.
  
  @param [number]: Value to find progress within given range
  @param [number]: Lower limit 
  @param [number]: Upper limit
  @return [number]: Progress of value within range as expressed 0-1
*/
var getProgressFromValue = exports.getProgressFromValue = function (value, from, to) {
  return (value - from) / (to - from);
};

/*
  Offset between two objects of numbers

  If property is found in b not present in a, it will return `0` for that prop.
  
  @param [Point]: First object
  @param [Point]: Second object
  @return [Offset]: Distance metrics between two points
*/
var offset = exports.offset = function (a, b) {
  var offset = {};

  for (var key in b) {
    if (b.hasOwnProperty(key)) {
      offset[key] = (0, _utils.hasProperty)(a, key) ? b[key] - a[key] : 0;
    }
  }

  return offset;
};

/*
  Point from angle and distance
  
  @param [object]: 2D point of origin
  @param [number]: Angle from origin
  @param [number]: Distance from origin
  @return [object]: Calculated 2D point
*/
var pointFromAngleAndDistance = exports.pointFromAngleAndDistance = function (origin, angle, distance) {
  angle = degreesToRadians(angle);

  return {
    x: distance * Math.cos(angle) + origin.x,
    y: distance * Math.sin(angle) + origin.y
  };
};

/*
  Convert radians to degrees
  
  @param [number]: Value in radians
  @return [number]: Value in degrees
*/
var radiansToDegrees = exports.radiansToDegrees = function (radians) {
  return radians * 180 / Math.PI;
};

/*
  Return random number between range
  
  @param [number] (optional): Output minimum
  @param [number] (optional): Output maximum
  @return [number]: Random number within range, or 0 and 1 if none provided
*/
var random = exports.random = function () {
  var min = arguments.length <= 0 || arguments[0] === undefined ? 0 : arguments[0];
  var max = arguments.length <= 1 || arguments[1] === undefined ? 1 : arguments[1];
  return Math.random() * (max - min) + min;
};

/*
  Calculate relative value
  
  Takes the operator and value from a string, ie "+=5", and applies
  to the current value to resolve a new target.
  
  @param [number]: Current value
  @param [string]: Relative value
  @return [number]: New value
*/
var relativeValue = exports.relativeValue = function (current, relative) {
  var newValue = current;
  var equation = relative.split('=');
  var operator = equation[0];

  var _findValueAndUnit = (0, _utils.findValueAndUnit)(equation[1]);

  var unit = _findValueAndUnit.unit;
  var value = _findValueAndUnit.value;


  value = parseFloat(value);

  switch (operator) {
    case '+':
      newValue += value;
      break;
    case '-':
      newValue -= value;
      break;
    case '*':
      newValue *= value;
      break;
    case '/':
      newValue /= value;
      break;
  }

  if (unit) {
    newValue += unit;
  }

  return newValue;
};

/*
  Restrict value to range
  
  Return value within the range of lowerLimit and upperLimit
  
  @param [number]: Value to keep within range
  @param [number]: Lower limit of range
  @param [number]: Upper limit of range
  @return [number]: Value as limited within given range
*/
var restrict = exports.restrict = function (value, min, max) {
  return Math.max(Math.min(value, max), min);
};

/*
  Framerate-independent smoothing

  @param [number]: New value
  @param [number]: Old value
  @param [number]: Frame duration
  @param [number] (optional): Smoothing (0 is none)
*/
var smooth = exports.smooth = function (newValue, oldValue, duration) {
  var smoothing = arguments.length <= 3 || arguments[3] === undefined ? 0 : arguments[3];
  return (0, _utils.toDecimal)(oldValue + duration * (newValue - oldValue) / Math.max(smoothing, duration));
};

/*
  Convert x per second to per frame velocity based on fps
  
  @param [number]: Unit per second
  @param [number]: Frame duration in ms
*/
var speedPerFrame = exports.speedPerFrame = function (xps, frameDuration) {
  return (0, _utils.isNum)(xps) ? xps / (1000 / frameDuration) : 0;
};

/*
  Convert velocity into velicity per second
  
  @param [number]: Unit per frame
  @param [number]: Frame duration in ms
*/
var speedPerSecond = exports.speedPerSecond = function (velocity, frameDuration) {
  return velocity * (1000 / frameDuration);
};

/*
  Create stepped version of 0-1 progress
  
  @param [number]: Current value
  @param [int]: Number of steps
  @return [number]: Stepped value
*/
var stepProgress = exports.stepProgress = function (progress, steps) {
  var segment = 1 / (steps - 1);
  var target = 1 - 1 / steps;
  var progressOfTarget = Math.min(progress / target, 1);

  return Math.floor(progressOfTarget / segment) * segment;
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9pbmMvY2FsYy5qcyJdLCJuYW1lcyI6WyJaRVJPX1BPSU5UIiwieCIsInkiLCJ6IiwiZGlzdGFuY2UxRCIsImEiLCJiIiwiTWF0aCIsImFicyIsImFuZ2xlIiwicmFkaWFuc1RvRGVncmVlcyIsImF0YW4yIiwiZGVncmVlc1RvUmFkaWFucyIsImRlZ3JlZXMiLCJQSSIsImRpbGF0ZSIsImRpbGF0aW9uIiwiZGlzdGFuY2UiLCJ4RGVsdGEiLCJ5RGVsdGEiLCJ6RGVsdGEiLCJzcXJ0IiwiZWFzZSIsInByb2dyZXNzIiwiZnJvbSIsInRvIiwicHJvZ3Jlc3NMaW1pdGVkIiwicmVzdHJpY3QiLCJlYXNlZFByb2dyZXNzIiwiZ2V0VmFsdWVGcm9tUHJvZ3Jlc3MiLCJoeXBvdGVudXNlIiwiZ2V0UHJvZ3Jlc3NGcm9tVmFsdWUiLCJ2YWx1ZSIsIm9mZnNldCIsImtleSIsImhhc093blByb3BlcnR5IiwicG9pbnRGcm9tQW5nbGVBbmREaXN0YW5jZSIsIm9yaWdpbiIsImNvcyIsInNpbiIsInJhZGlhbnMiLCJyYW5kb20iLCJtaW4iLCJtYXgiLCJyZWxhdGl2ZVZhbHVlIiwiY3VycmVudCIsInJlbGF0aXZlIiwibmV3VmFsdWUiLCJlcXVhdGlvbiIsInNwbGl0Iiwib3BlcmF0b3IiLCJ1bml0IiwicGFyc2VGbG9hdCIsInNtb290aCIsIm9sZFZhbHVlIiwiZHVyYXRpb24iLCJzbW9vdGhpbmciLCJzcGVlZFBlckZyYW1lIiwieHBzIiwiZnJhbWVEdXJhdGlvbiIsInNwZWVkUGVyU2Vjb25kIiwidmVsb2NpdHkiLCJzdGVwUHJvZ3Jlc3MiLCJzdGVwcyIsInNlZ21lbnQiLCJ0YXJnZXQiLCJwcm9ncmVzc09mVGFyZ2V0IiwiZmxvb3IiXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7O0FBT0EsSUFBTUEsYUFBYTtBQUNqQkMsS0FBRyxDQURjO0FBRWpCQyxLQUFHLENBRmM7QUFHakJDLEtBQUc7QUFIYyxDQUFuQjs7QUFNQSxJQUFNQyxhQUFhLFVBQUND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U0FBNkJFLFlBQVksT0FBT0YsYUFBbkIsQ0FBN0I7QUFBQSxDQUF2Qjs7QUFFUDs7Ozs7OztBQU9PLElBQU1HLHNDQUFlLFVBQUN2QyxRQUFELEVBQVd3QyxLQUFYLEVBQXFCO0FBQy9DLE1BQU1DLFVBQVUsS0FBS0QsUUFBUSxDQUFiLENBQWhCO0FBQ0EsTUFBTUUsU0FBUyxJQUFLLElBQUlGLEtBQXhCO0FBQ0EsTUFBTUcsbUJBQW1CM0QsS0FBS21DLEdBQUwsQ0FBU25CLFdBQVcwQyxNQUFwQixFQUE0QixDQUE1QixDQUF6Qjs7QUFFQSxTQUFPMUQsS0FBSzRELEtBQUwsQ0FBV0QsbUJBQW1CRixPQUE5QixJQUF5Q0EsT0FBaEQ7QUFDRCxDQU5NIiwiZmlsZSI6ImNhbGMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBoYXNQcm9wZXJ0eSxcbiAgaXNOdW0sXG4gIGZpbmRWYWx1ZUFuZFVuaXQsXG4gIHRvRGVjaW1hbFxufSBmcm9tICcuL3V0aWxzJztcblxuY29uc3QgWkVST19QT0lOVCA9IHtcbiAgeDogMCxcbiAgeTogMCxcbiAgejogMFxufTtcblxuY29uc3QgZGlzdGFuY2UxRCA9IChhLCBiKSA9PiBNYXRoLmFicyhhIC0gYik7XG5cbi8qXG4gIEFuZ2xlIGJldHdlZW4gcG9pbnRzXG4gIFxuICBUcmFuc2xhdGVzIHRoZSBoeXBvdGhldGljYWwgbGluZSBzbyB0aGF0IHRoZSAnZnJvbScgY29vcmRpbmF0ZXNcbiAgYXJlIGF0IDAsMFxuICBcbiAgQHBhcmFtIFtvYmplY3RdOiBYIGFuZCBZIGNvb3JkaW5hdGVzIG9mIGZyb20gcG9pbnRcbiAgQHBhcmFtIFtvYmplY3RdOiBYIGFuZCBZIGNvcmRpbmF0ZXMgb2YgdG8gcG9pbnRcbiAgQHJldHVybiBbcmFkaWFuXTogQW5nbGUgYmV0d2VlbiB0aGUgdHdvIHBvaW50cyBpbiByYWRpYW5zXG4qL1xuZXhwb3J0IGNvbnN0IGFuZ2xlID0gKGEsIGIgPSBaRVJPX1BPSU5UKSA9PiByYWRpYW5zVG9EZWdyZWVzKE1hdGguYXRhbjIoYS54IC0gYi54LCBhLnkgLSBiLnkpKTtcblxuLypcbiAgQ29udmVydCBkZWdyZWVzIHRvIHJhZGlhbnNcbiAgXG4gIEBwYXJhbSBbbnVtYmVyXTogVmFsdWUgaW4gZGVncmVlc1xuICBAcmV0dXJuIFtudW1iZXJdOiBWYWx1ZSBpbiByYWRpYW5zXG4qL1xuZXhwb3J0IGNvbnN0IGRlZ3JlZXNUb1JhZGlhbnMgPSAoZGVncmVlcykgPT4gZGVncmVlcyAqIE1hdGguUEkgLyAxODA7XG5cbi8qXG4gIERpbGF0ZVxuICBcbiAgQ2hhbmdlIHRoZSBwcm9ncmVzc2lvbiBiZXR3ZWVuIGEgYW5kIGIgYWNjb3JkaW5nIHRvIGRpbGF0aW9uLlxuICBcbiAgU28gZGlsYXRpb24gPSAwLjUgd291bGQgY2hhbmdlXG4gIFxuICBhIC0tLS0tLS0tLSBiXG4gIFxuICB0b1xuICBcbiAgYSAtLS0tIGJcbiAgXG4gIEBwYXJhbSBbbnVtYmVyXTogUHJldmlvdXMgdmFsdWVcbiAgQHBhcmFtIFtudW1iZXJdOiBDdXJyZW50IHZhbHVlXG4gIEBwYXJhbSBbbnVtYmVyXTogRGlsYXRlIHByb2dyZXNzIGJ5IHhcbiAgQHJldHVybiBbbnVtYmVyXTogUHJldmlvdXMgdmFsdWUgcGx1cyB0aGUgZGlsYXRlZCBkaWZmZXJlbmNlXG4qL1xuZXhwb3J0IGNvbnN0IGRpbGF0ZSA9IChhLCBiLCBkaWxhdGlvbikgPT4gYSArICgoYiAtIGEpICogZGlsYXRpb24pO1xuXG4vKlxuICBEaXN0YW5jZVxuICBcbiAgUmV0dXJucyB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gbiBkaW1lbnNpb25hbCBwb2ludHMuXG4gIFxuICBAcGFyYW0gW29iamVjdC9udW1iZXJdOiB4IGFuZCB5IG9yIGp1c3QgeCBvZiBwb2ludCBBXG4gIEBwYXJhbSBbb2JqZWN0L251bWJlcl06IChvcHRpb25hbCk6IHggYW5kIHkgb3IganVzdCB4IG9mIHBvaW50IEJcbiAgQHJldHVybiBbbnVtYmVyXTogVGhlIGRpc3RhbmNlIGJldHdlZW4gdGhlIHR3byBwb2ludHNcbiovXG5leHBvcnQgY29uc3QgZGlzdGFuY2UgPSAoYSwgYiA9IFpFUk9fUE9JTlQpID0+IHtcbiAgLy8gMUQgZGltZW5zaW9uc1xuICBpZiAoaXNOdW0oYSkpIHtcbiAgICByZXR1cm4gZGlzdGFuY2UxRChhLCBiKTtcblxuICAvLyBNdWx0aS1kaW1lbnNpb25hbFxuICB9IGVsc2Uge1xuICAgIGNvbnN0IHhEZWx0YSA9IGRpc3RhbmNlMUQoYS54LCBiLngpO1xuICAgIGNvbnN0IHlEZWx0YSA9IGRpc3RhbmNlMUQoYS55LCBiLnkpO1xuICAgIGNvbnN0IHpEZWx0YSA9IChpc051bShhLnopKSA/IGRpc3RhbmNlMUQoYS56LCBiLnopIDogMDtcblxuICAgIHJldHVybiBNYXRoLnNxcnQoKHhEZWx0YSAqKiAyKSArICh5RGVsdGEgKiogMikgKyAoekRlbHRhICoqIDIpKTtcbiAgfVxufTtcblxuLypcbiAgRWFzZSB2YWx1ZSB3aXRoaW4gcmFuZ2VkIHBhcmFtZXRlcnNcbiAgXG4gIEBwYXJhbSBbbnVtYmVyXTogUHJvZ3Jlc3MgYmV0d2VlbiAwIGFuZCAxXG4gIEBwYXJhbSBbbnVtYmVyXTogVmFsdWUgb2YgMCBwcm9ncmVzc1xuICBAcGFyYW0gW251bWJlcl06IFZhbHVlIG9mIDEgcHJvZ3Jlc3NcbiAgQHBhcmFtIFtzdHJpbmcgfHwgZnVuY3Rpb25dOiBOYW1lIG9mIHByZXNldCBlYXNpbmdcbiAgICB0byB1c2Ugb3IgZ2VuZXJhdGVkIGVhc2luZyBmdW5jdGlvblxuICBAcmV0dXJuIFtudW1iZXJdOiBWYWx1ZSBvZiBlYXNlZCBwcm9ncmVzcyBpbiByYW5nZVxuKi8gXG5leHBvcnQgY29uc3QgZWFzZSA9IChwcm9ncmVzcywgZnJvbSwgdG8sIGVhc2UpID0+IHtcbiAgY29uc3QgcHJvZ3Jlc3NMaW1pdGVkID0gcmVzdHJpY3QocHJvZ3Jlc3MsIDAsIDEpO1xuICBjb25zdCBlYXNlZFByb2dyZXNzID0gZWFzZShwcm9ncmVzc0xpbWl0ZWQpO1xuXG4gIHJldHVybiBnZXRWYWx1ZUZyb21Qcm9ncmVzcyhlYXNlZFByb2dyZXNzLCBmcm9tLCB0byk7XG59O1xuIFxuLypcbiAgSHlwb3RlbnVzZVxuICBcbiAgUmV0dXJucyB0aGUgaHlwb3RlbnVzZSwgc2lkZSBDLCBnaXZlbiB0aGUgbGVuZ3RocyBvZiBzaWRlcyBBIGFuZCBCLlxuICBcbiAgQHBhcmFtIFtudW1iZXJdOiBMZW5ndGggb2YgQVxuICBAcGFyYW0gW251bWJlcl06IExlbmd0aCBvZiBCXG4gIEByZXR1cm4gW251bWJlcl06IExlbmd0aCBvZiBDXG4qL1xuZXhwb3J0IGNvbnN0IGh5cG90ZW51c2UgPSAoYSwgYikgPT4gTWF0aC5zcXJ0KChhICogYSkgKyAoYiAqIGIpKTtcblxuLypcbiAgVmFsdWUgaW4gcmFuZ2UgZnJvbSBwcm9ncmVzc1xuICBcbiAgR2l2ZW4gYSBsb3dlciBsaW1pdCBhbmQgYW4gdXBwZXIgbGltaXQsIHdlIHJldHVybiB0aGUgdmFsdWUgd2l0aGluXG4gIHRoYXQgcmFuZ2UgYXMgZXhwcmVzc2VkIGJ5IHByb2dyZXNzIChhIG51bWJlciBmcm9tIDAtMSlcbiAgXG4gIEBwYXJhbSBbbnVtYmVyXTogVGhlIHByb2dyZXNzIGJldHdlZW4gbG93ZXIgYW5kIHVwcGVyIGxpbWl0cyBleHByZXNzZWQgMC0xXG4gIEBwYXJhbSBbbnVtYmVyXTogTG93ZXIgbGltaXQgb2YgcmFuZ2VcbiAgQHBhcmFtIFtudW1iZXJdOiBVcHBlciBsaW1pdCBvZiByYW5nZVxuICBAcmV0dXJuIFtudW1iZXJdOiBWYWx1ZSBhcyBjYWxjdWxhdGVkIGZyb20gcHJvZ3Jlc3Mgd2l0aGluIHJhbmdlIChub3QgbGltaXRlZCB3aXRoaW4gcmFuZ2UpXG4qL1xuZXhwb3J0IGNvbnN0IGdldFZhbHVlRnJvbVByb2dyZXNzID0gKHByb2dyZXNzLCBmcm9tLCB0bykgPT4gKC0gcHJvZ3Jlc3MgKiBmcm9tKSArIChwcm9ncmVzcyAqIHRvKSArIGZyb207XG5cbi8qXG4gIFByb2dyZXNzIHdpdGhpbiBnaXZlbiByYW5nZVxuICBcbiAgR2l2ZW4gYSBsb3dlciBsaW1pdCBhbmQgYW4gdXBwZXIgbGltaXQsIHdlIHJldHVybiB0aGUgcHJvZ3Jlc3NcbiAgKGV4cHJlc3NlZCBhcyBhIG51bWJlciAwLTEpIHJlcHJlc2VudGVkIGJ5IHRoZSBnaXZlbiB2YWx1ZSwgYW5kXG4gIGxpbWl0IHRoYXQgcHJvZ3Jlc3MgdG8gd2l0aGluIDAtMS5cbiAgXG4gIEBwYXJhbSBbbnVtYmVyXTogVmFsdWUgdG8gZmluZCBwcm9ncmVzcyB3aXRoaW4gZ2l2ZW4gcmFuZ2VcbiAgQHBhcmFtIFtudW1iZXJdOiBMb3dlciBsaW1pdCBcbiAgQHBhcmFtIFtudW1iZXJdOiBVcHBlciBsaW1pdFxuICBAcmV0dXJuIFtudW1iZXJdOiBQcm9ncmVzcyBvZiB2YWx1ZSB3aXRoaW4gcmFuZ2UgYXMgZXhwcmVzc2VkIDAtMVxuKi9cbmV4cG9ydCBjb25zdCBnZXRQcm9ncmVzc0Zyb21WYWx1ZSA9ICh2YWx1ZSwgZnJvbSwgdG8pID0+ICh2YWx1ZSAtIGZyb20pIC8gKHRvIC0gZnJvbSk7XG5cbi8qXG4gIE9mZnNldCBiZXR3ZWVuIHR3byBvYmplY3RzIG9mIG51bWJlcnNcblxuICBJZiBwcm9wZXJ0eSBpcyBmb3VuZCBpbiBiIG5vdCBwcmVzZW50IGluIGEsIGl0IHdpbGwgcmV0dXJuIGAwYCBmb3IgdGhhdCBwcm9wLlxuICBcbiAgQHBhcmFtIFtQb2ludF06IEZpcnN0IG9iamVjdFxuICBAcGFyYW0gW1BvaW50XTogU2Vjb25kIG9iamVjdFxuICBAcmV0dXJuIFtPZmZzZXRdOiBEaXN0YW5jZSBtZXRyaWNzIGJldHdlZW4gdHdvIHBvaW50c1xuKi9cbmV4cG9ydCBjb25zdCBvZmZzZXQgPSAoYSwgYikgPT4ge1xuICBjb25zdCBvZmZzZXQgPSB7fTtcblxuICBmb3IgKGxldCBrZXkgaW4gYikge1xuICAgIGlmIChiLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIG9mZnNldFtrZXldID0gaGFzUHJvcGVydHkoYSwga2V5KSA/IGJba2V5XSAtIGFba2V5XSA6IDA7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9mZnNldDtcbn07XG5cbi8qXG4gIFBvaW50IGZyb20gYW5nbGUgYW5kIGRpc3RhbmNlXG4gIFxuICBAcGFyYW0gW29iamVjdF06IDJEIHBvaW50IG9mIG9yaWdpblxuICBAcGFyYW0gW251bWJlcl06IEFuZ2xlIGZyb20gb3JpZ2luXG4gIEBwYXJhbSBbbnVtYmVyXTogRGlzdGFuY2UgZnJvbSBvcmlnaW5cbiAgQHJldHVybiBbb2JqZWN0XTogQ2FsY3VsYXRlZCAyRCBwb2ludFxuKi9cbmV4cG9ydCBjb25zdCBwb2ludEZyb21BbmdsZUFuZERpc3RhbmNlID0gKG9yaWdpbiwgYW5nbGUsIGRpc3RhbmNlKSA9PiB7XG4gIGFuZ2xlID0gZGVncmVlc1RvUmFkaWFucyhhbmdsZSk7XG5cbiAgcmV0dXJuIHtcbiAgICB4OiBkaXN0YW5jZSAqIE1hdGguY29zKGFuZ2xlKSArIG9yaWdpbi54LFxuICAgIHk6IGRpc3RhbmNlICogTWF0aC5zaW4oYW5nbGUpICsgb3JpZ2luLnlcbiAgfTtcbn07XG5cbi8qXG4gIENvbnZlcnQgcmFkaWFucyB0byBkZWdyZWVzXG4gIFxuICBAcGFyYW0gW251bWJlcl06IFZhbHVlIGluIHJhZGlhbnNcbiAgQHJldHVybiBbbnVtYmVyXTogVmFsdWUgaW4gZGVncmVlc1xuKi9cbmV4cG9ydCBjb25zdCByYWRpYW5zVG9EZWdyZWVzID0gKHJhZGlhbnMpID0+IHJhZGlhbnMgKiAxODAgLyBNYXRoLlBJO1xuXG4vKlxuICBSZXR1cm4gcmFuZG9tIG51bWJlciBiZXR3ZWVuIHJhbmdlXG4gIFxuICBAcGFyYW0gW251bWJlcl0gKG9wdGlvbmFsKTogT3V0cHV0IG1pbmltdW1cbiAgQHBhcmFtIFtudW1iZXJdIChvcHRpb25hbCk6IE91dHB1dCBtYXhpbXVtXG4gIEByZXR1cm4gW251bWJlcl06IFJhbmRvbSBudW1iZXIgd2l0aGluIHJhbmdlLCBvciAwIGFuZCAxIGlmIG5vbmUgcHJvdmlkZWRcbiovXG5leHBvcnQgY29uc3QgcmFuZG9tID0gKG1pbiA9IDAsIG1heCA9IDEpID0+IE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluKSArIG1pbjtcblxuLypcbiAgQ2FsY3VsYXRlIHJlbGF0aXZlIHZhbHVlXG4gIFxuICBUYWtlcyB0aGUgb3BlcmF0b3IgYW5kIHZhbHVlIGZyb20gYSBzdHJpbmcsIGllIFwiKz01XCIsIGFuZCBhcHBsaWVzXG4gIHRvIHRoZSBjdXJyZW50IHZhbHVlIHRvIHJlc29sdmUgYSBuZXcgdGFyZ2V0LlxuICBcbiAgQHBhcmFtIFtudW1iZXJdOiBDdXJyZW50IHZhbHVlXG4gIEBwYXJhbSBbc3RyaW5nXTogUmVsYXRpdmUgdmFsdWVcbiAgQHJldHVybiBbbnVtYmVyXTogTmV3IHZhbHVlXG4qL1xuZXhwb3J0IGNvbnN0IHJlbGF0aXZlVmFsdWUgPSAoY3VycmVudCwgcmVsYXRpdmUpID0+IHtcbiAgbGV0IG5ld1ZhbHVlID0gY3VycmVudDtcbiAgY29uc3QgZXF1YXRpb24gPSByZWxhdGl2ZS5zcGxpdCgnPScpO1xuICBjb25zdCBvcGVyYXRvciA9IGVxdWF0aW9uWzBdO1xuICBsZXQgeyB1bml0LCB2YWx1ZSB9ID0gZmluZFZhbHVlQW5kVW5pdChlcXVhdGlvblsxXSk7XG5cbiAgdmFsdWUgPSBwYXJzZUZsb2F0KHZhbHVlKTtcblxuICBzd2l0Y2ggKG9wZXJhdG9yKSB7XG4gIGNhc2UgJysnOlxuICAgIG5ld1ZhbHVlICs9IHZhbHVlO1xuICAgIGJyZWFrO1xuICBjYXNlICctJzpcbiAgICBuZXdWYWx1ZSAtPSB2YWx1ZTtcbiAgICBicmVhaztcbiAgY2FzZSAnKic6XG4gICAgbmV3VmFsdWUgKj0gdmFsdWU7XG4gICAgYnJlYWs7XG4gIGNhc2UgJy8nOlxuICAgIG5ld1ZhbHVlIC89IHZhbHVlO1xuICAgIGJyZWFrO1xuICB9XG4gIFxuICBpZiAodW5pdCkge1xuICAgIG5ld1ZhbHVlICs9IHVuaXQ7XG4gIH1cblxuICByZXR1cm4gbmV3VmFsdWU7XG59O1xuXG4vKlxuICBSZXN0cmljdCB2YWx1ZSB0byByYW5nZVxuICBcbiAgUmV0dXJuIHZhbHVlIHdpdGhpbiB0aGUgcmFuZ2Ugb2YgbG93ZXJMaW1pdCBhbmQgdXBwZXJMaW1pdFxuICBcbiAgQHBhcmFtIFtudW1iZXJdOiBWYWx1ZSB0byBrZWVwIHdpdGhpbiByYW5nZVxuICBAcGFyYW0gW251bWJlcl06IExvd2VyIGxpbWl0IG9mIHJhbmdlXG4gIEBwYXJhbSBbbnVtYmVyXTogVXBwZXIgbGltaXQgb2YgcmFuZ2VcbiAgQHJldHVybiBbbnVtYmVyXTogVmFsdWUgYXMgbGltaXRlZCB3aXRoaW4gZ2l2ZW4gcmFuZ2VcbiovXG5leHBvcnQgY29uc3QgcmVzdHJpY3QgPSAodmFsdWUsIG1pbiwgbWF4KSA9PiBNYXRoLm1heChNYXRoLm1pbih2YWx1ZSwgbWF4KSwgbWluKTtcblxuLypcbiAgRnJhbWVyYXRlLWluZGVwZW5kZW50IHNtb290aGluZ1xuXG4gIEBwYXJhbSBbbnVtYmVyXTogTmV3IHZhbHVlXG4gIEBwYXJhbSBbbnVtYmVyXTogT2xkIHZhbHVlXG4gIEBwYXJhbSBbbnVtYmVyXTogRnJhbWUgZHVyYXRpb25cbiAgQHBhcmFtIFtudW1iZXJdIChvcHRpb25hbCk6IFNtb290aGluZyAoMCBpcyBub25lKVxuKi9cbmV4cG9ydCBjb25zdCBzbW9vdGggPSAobmV3VmFsdWUsIG9sZFZhbHVlLCBkdXJhdGlvbiwgc21vb3RoaW5nID0gMCkgPT4gdG9EZWNpbWFsKG9sZFZhbHVlICsgKGR1cmF0aW9uICogKG5ld1ZhbHVlIC0gb2xkVmFsdWUpIC8gTWF0aC5tYXgoc21vb3RoaW5nLCBkdXJhdGlvbikpKTtcblxuLypcbiAgQ29udmVydCB4IHBlciBzZWNvbmQgdG8gcGVyIGZyYW1lIHZlbG9jaXR5IGJhc2VkIG9uIGZwc1xuICBcbiAgQHBhcmFtIFtudW1iZXJdOiBVbml0IHBlciBzZWNvbmRcbiAgQHBhcmFtIFtudW1iZXJdOiBGcmFtZSBkdXJhdGlvbiBpbiBtc1xuKi9cbmV4cG9ydCBjb25zdCBzcGVlZFBlckZyYW1lID0gKHhwcywgZnJhbWVEdXJhdGlvbikgPT4gKGlzTnVtKHhwcykpID8geHBzIC8gKDEwMDAgLyBmcmFtZUR1cmF0aW9uKSA6IDA7XG5cbi8qXG4gIENvbnZlcnQgdmVsb2NpdHkgaW50byB2ZWxpY2l0eSBwZXIgc2Vjb25kXG4gIFxuICBAcGFyYW0gW251bWJlcl06IFVuaXQgcGVyIGZyYW1lXG4gIEBwYXJhbSBbbnVtYmVyXTogRnJhbWUgZHVyYXRpb24gaW4gbXNcbiovXG5leHBvcnQgY29uc3Qgc3BlZWRQZXJTZWNvbmQgPSAodmVsb2NpdHksIGZyYW1lRHVyYXRpb24pID0+IHZlbG9jaXR5ICogKDEwMDAgLyBmcmFtZUR1cmF0aW9uKTtcblxuLypcbiAgQ3JlYXRlIHN0ZXBwZWQgdmVyc2lvbiBvZiAwLTEgcHJvZ3Jlc3NcbiAgXG4gIEBwYXJhbSBbbnVtYmVyXTogQ3VycmVudCB2YWx1ZVxuICBAcGFyYW0gW2ludF06IE51bWJlciBvZiBzdGVwc1xuICBAcmV0dXJuIFtudW1iZXJdOiBTdGVwcGVkIHZhbHVlXG4qL1xuZXhwb3J0IGNvbnN0IHN0ZXBQcm9ncmVzcyA9IChwcm9ncmVzcywgc3RlcHMpID0+IHtcbiAgY29uc3Qgc2VnbWVudCA9IDEgLyAoc3RlcHMgLSAxKTtcbiAgY29uc3QgdGFyZ2V0ID0gMSAtICgxIC8gc3RlcHMpO1xuICBjb25zdCBwcm9ncmVzc09mVGFyZ2V0ID0gTWF0aC5taW4ocHJvZ3Jlc3MgLyB0YXJnZXQsIDEpO1xuXG4gIHJldHVybiBNYXRoLmZsb29yKHByb2dyZXNzT2ZUYXJnZXQgLyBzZWdtZW50KSAqIHNlZ21lbnQ7XG59OyJdfQ==