'use strict';

exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _Action2 = require('./Action');

var _Action3 = _interopRequireDefault(_Action2);

var _Pointer = require('../input/Pointer');

var _Pointer2 = _interopRequireDefault(_Pointer);

var _calc = require('../inc/calc');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/*
  Scrape x/y coordinates from provided event

  @param [event]
  @return [object]
*/
var mouseEventToPoint = function (e) {
  return {
    x: e.pageX,
    y: e.pageY
  };
};

var touchEventToPoint = function (_ref) {
  var changedTouches = _ref.changedTouches;
  return {
    x: changedTouches[0].clientX,
    y: changedTouches[0].clientY
  };
};

var createPointer = function (e, preventDefault) {
  return e.touches ? new _Pointer2.default(touchEventToPoint(e), 'touchmove', touchEventToPoint, preventDefault) : new _Pointer2.default(mouseEventToPoint(e), 'mousemove', mouseEventToPoint, preventDefault);
};

var getActualEvent = function (e) {
  return e.originalEvent || e;
};

var Track = function (_Action) {
  _inherits(Track, _Action);

  function Track() {
    _classCallCheck(this, Track);

    return _possibleConstructorReturn(this, _Action.apply(this, arguments));
  }

  Track.prototype.start = function start(input) {
    var preventDefault = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];

    _Action.prototype.start.call(this);

    if (input) {
      this.input = input.state ? input : createPointer(getActualEvent(input), preventDefault);
    }

    this.inputOffset = {};
    this.inputOrigin = _extends({}, this.input.state);
    this.input.start();

    return this;
  };

  Track.prototype.stop = function stop() {
    _Action.prototype.stop.call(this);
    this.input.stop();

    return this;
  };

  Track.prototype.onUpdate = function onUpdate(track, frameStamp, elapsed) {
    this.inputOffset = (0, _calc.offset)(this.inputOrigin, this.input.state);

    for (var i = 0; i < this.numValueKeys; i++) {
      var key = this.valueKeys[i];

      if (this.inputOffset.hasOwnProperty(key)) {
        var value = this.values[key];
        var inputProp = value.hasOwnProperty('watch') ? value.watch : key;

        if (value.direct) {
          value.current = this.input.state[inputProp];
        } else {
          value.current = value.from + this.inputOffset[inputProp];
        }

        // Smooth value if we have smoothing
        if (value.smooth) {
          value.current = (0, _calc.smooth)(value.current, value.prev, elapsed, value.smooth);
        }
      }
    }
  };

  return Track;
}(_Action3.default);

Track.prototype.defaultValueProp = 'watch';
Track.prototype.defaultValue = _Action3.default.extendDefaultValue({
  direct: false,
  from: 0
});

exports.default = Track;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9hY3Rpb25zL1RyYWNrLmpzIl0sIm5hbWVzIjpbIm1vdXNlRXZlbnRUb1BvaW50IiwiZSIsIngiLCJwYWdlWCIsInkiLCJwYWdlWSIsInRvdWNoRXZlbnRUb1BvaW50IiwiY2hhbmdlZFRvdWNoZXMiLCJjbGllbnRYIiwiY2xpZW50WSIsImNyZWF0ZVBvaW50ZXIiLCJwcmV2ZW50RGVmYXVsdCIsInRvdWNoZXMiLCJnZXRBY3R1YWxFdmVudCIsIm9yaWdpbmFsRXZlbnQiLCJUcmFjayIsInN0YXJ0IiwiaW5wdXQiLCJzdGF0ZSIsImlucHV0T2Zmc2V0IiwiaW5wdXRPcmlnaW4iLCJzdG9wIiwib25VcGRhdGUiLCJ0cmFjayIsImZyYW1lU3RhbXAiLCJlbGFwc2VkIiwiaSIsIm51bVZhbHVlS2V5cyIsImtleSIsInZhbHVlS2V5cyIsImhhc093blByb3BlcnR5IiwidmFsdWUiLCJ2YWx1ZXMiLCJpbnB1dFByb3AiLCJ3YXRjaCIsImRpcmVjdCIsImN1cnJlbnQiLCJmcm9tIiwic21vb3RoIiwicHJldiIsInByb3RvdHlwZSIsImRlZmF1bHRWYWx1ZVByb3AiLCJkZWZhdWx0VmFsdWUiLCJleHRlbmREZWZhdWx0VmFsdWUiXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7OztBQUVBOzs7Ozs7QUFNQSxJQUFNQSxvQkFBb0IsVUFBQ0MsQ0FBRDtBQUFBLFNBQVE7QUFDaENDLE9BQUdELEVBQUVFLEtBRDJCO0FBRWhDQyxPQUFHSCxFQUFFSTtBQUYyQixHQUFSO0FBQUEsQ0FBMUI7O0FBS0EsSUFBTUMsb0JBQW9CO0FBQUEsTUFBR0MsY0FBSCxRQUFHQSxjQUFIO0FBQUEsU0FBeUI7QUFDakRMLE9BQUdLLGVBQWUsQ0FBZixFQUFrQkMsT0FENEI7QUFFakRKLE9BQUdHLGVBQWUsQ0FBZixFQUFrQkU7QUFGNEIsR0FBekI7QUFBQSxDQUExQjs7QUFLQSxJQUFNQyxnQkFBZ0IsVUFBQ1QsQ0FBRCxFQUFJVSxjQUFKO0FBQUEsU0FBdUJWLEVBQUVXLE9BQUYsR0FDM0Msc0JBQVlOLGtCQUFrQkwsQ0FBbEIsQ0FBWixFQUFrQyxXQUFsQyxFQUErQ0ssaUJBQS9DLEVBQWtFSyxjQUFsRSxDQUQyQyxHQUUzQyxzQkFBWVgsa0JBQWtCQyxDQUFsQixDQUFaLEVBQWtDLFdBQWxDLEVBQStDRCxpQkFBL0MsRUFBa0VXLGNBQWxFLENBRm9CO0FBQUEsQ0FBdEI7O0FBSUEsSUFBTUUsaUJBQWlCLFVBQUNaLENBQUQ7QUFBQSxTQUFPQSxFQUFFYSxhQUFGLElBQW1CYixDQUExQjtBQUFBLENBQXZCOztJQUVNYyxLO1lBQUFBLEs7O1dBQUFBLEs7MEJBQUFBLEs7Ozs7O0FBQUFBLE8sV0FDSkMsSyxrQkFBTUMsSyxFQUE4QjtBQUFBLFFBQXZCTixjQUF1Qix5REFBTixJQUFNOztBQUNsQyxzQkFBTUssS0FBTjs7QUFFQSxRQUFJQyxLQUFKLEVBQVc7QUFDVCxXQUFLQSxLQUFMLEdBQWFBLE1BQU1DLEtBQU4sR0FBY0QsS0FBZCxHQUFzQlAsY0FBY0csZUFBZUksS0FBZixDQUFkLEVBQXFDTixjQUFyQyxDQUFuQztBQUNEOztBQUVELFNBQUtRLFdBQUwsR0FBbUIsRUFBbkI7QUFDQSxTQUFLQyxXQUFMLGdCQUF3QixLQUFLSCxLQUFMLENBQVdDLEtBQW5DO0FBQ0EsU0FBS0QsS0FBTCxDQUFXRCxLQUFYOztBQUVBLFdBQU8sSUFBUDtBQUNELEc7O0FBYkdELE8sV0FlSk0sSSxtQkFBTztBQUNMLHNCQUFNQSxJQUFOO0FBQ0EsU0FBS0osS0FBTCxDQUFXSSxJQUFYOztBQUVBLFdBQU8sSUFBUDtBQUNELEc7O0FBcEJHTixPLFdBc0JKTyxRLHFCQUFTQyxLLEVBQU9DLFUsRUFBWUMsTyxFQUFTO0FBQ25DLFNBQUtOLFdBQUwsR0FBbUIsa0JBQU8sS0FBS0MsV0FBWixFQUF5QixLQUFLSCxLQUFMLENBQVdDLEtBQXBDLENBQW5COztBQUVBLFNBQUssSUFBSVEsSUFBSSxDQUFiLEVBQWdCQSxJQUFJLEtBQUtDLFlBQXpCLEVBQXVDRCxHQUF2QyxFQUE0QztBQUMxQyxVQUFNRSxNQUFNLEtBQUtDLFNBQUwsQ0FBZUgsQ0FBZixDQUFaOztBQUVBLFVBQUksS0FBS1AsV0FBTCxDQUFpQlcsY0FBakIsQ0FBZ0NGLEdBQWhDLENBQUosRUFBMEM7QUFDeEMsWUFBTUcsUUFBUSxLQUFLQyxNQUFMLENBQVlKLEdBQVosQ0FBZDtBQUNBLFlBQU1LLFlBQVlGLE1BQU1ELGNBQU4sQ0FBcUIsT0FBckIsSUFBZ0NDLE1BQU1HLEtBQXRDLEdBQThDTixHQUFoRTs7QUFFQSxZQUFJRyxNQUFNSSxNQUFWLEVBQWtCO0FBQ2hCSixnQkFBTUssT0FBTixHQUFnQixLQUFLbkIsS0FBTCxDQUFXQyxLQUFYLENBQWlCZSxTQUFqQixDQUFoQjtBQUNELFNBRkQsTUFFTztBQUNMRixnQkFBTUssT0FBTixHQUFnQkwsTUFBTU0sSUFBTixHQUFhLEtBQUtsQixXQUFMLENBQWlCYyxTQUFqQixDQUE3QjtBQUNEOztBQUVEO0FBQ0EsWUFBSUYsTUFBTU8sTUFBVixFQUFrQjtBQUNoQlAsZ0JBQU1LLE9BQU4sR0FBZ0Isa0JBQU9MLE1BQU1LLE9BQWIsRUFBc0JMLE1BQU1RLElBQTVCLEVBQWtDZCxPQUFsQyxFQUEyQ00sTUFBTU8sTUFBakQsQ0FBaEI7QUFDRDtBQUNGO0FBQ0Y7QUFDRixHOztTQTVDR3ZCLEs7OztBQStDTkEsTUFBTXlCLFNBQU4sQ0FBZ0JDLGdCQUFoQixHQUFtQyxPQUFuQztBQUNBMUIsTUFBTXlCLFNBQU4sQ0FBZ0JFLFlBQWhCLEdBQStCLGlCQUFPQyxrQkFBUCxDQUEwQjtBQUN2RFIsVUFBUSxLQUQrQztBQUV2REUsUUFBTTtBQUZpRCxDQUExQixDQUEvQjs7a0JBS2V0QixLIiwiZmlsZSI6IlRyYWNrLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEFjdGlvbiBmcm9tICcuL0FjdGlvbic7XG5pbXBvcnQgUG9pbnRlciBmcm9tICcuLi9pbnB1dC9Qb2ludGVyJztcbmltcG9ydCB7IHNtb290aCwgb2Zmc2V0IH0gZnJvbSAnLi4vaW5jL2NhbGMnO1xuXG4vKlxuICBTY3JhcGUgeC95IGNvb3JkaW5hdGVzIGZyb20gcHJvdmlkZWQgZXZlbnRcblxuICBAcGFyYW0gW2V2ZW50XVxuICBAcmV0dXJuIFtvYmplY3RdXG4qL1xuY29uc3QgbW91c2VFdmVudFRvUG9pbnQgPSAoZSkgPT4gKHtcbiAgeDogZS5wYWdlWCxcbiAgeTogZS5wYWdlWVxufSk7XG5cbmNvbnN0IHRvdWNoRXZlbnRUb1BvaW50ID0gKHsgY2hhbmdlZFRvdWNoZXMgfSkgPT4gKHtcbiAgeDogY2hhbmdlZFRvdWNoZXNbMF0uY2xpZW50WCxcbiAgeTogY2hhbmdlZFRvdWNoZXNbMF0uY2xpZW50WVxufSk7XG5cbmNvbnN0IGNyZWF0ZVBvaW50ZXIgPSAoZSwgcHJldmVudERlZmF1bHQpID0+IGUudG91Y2hlcyA/XG4gIG5ldyBQb2ludGVyKHRvdWNoRXZlbnRUb1BvaW50KGUpLCAndG91Y2htb3ZlJywgdG91Y2hFdmVudFRvUG9pbnQsIHByZXZlbnREZWZhdWx0KSA6IFxuICBuZXcgUG9pbnRlcihtb3VzZUV2ZW50VG9Qb2ludChlKSwgJ21vdXNlbW92ZScsIG1vdXNlRXZlbnRUb1BvaW50LCBwcmV2ZW50RGVmYXVsdCk7XG5cbmNvbnN0IGdldEFjdHVhbEV2ZW50ID0gKGUpID0+IGUub3JpZ2luYWxFdmVudCB8fCBlO1xuXG5jbGFzcyBUcmFjayBleHRlbmRzIEFjdGlvbiB7XG4gIHN0YXJ0KGlucHV0LCBwcmV2ZW50RGVmYXVsdCA9IHRydWUpIHtcbiAgICBzdXBlci5zdGFydCgpO1xuXG4gICAgaWYgKGlucHV0KSB7XG4gICAgICB0aGlzLmlucHV0ID0gaW5wdXQuc3RhdGUgPyBpbnB1dCA6IGNyZWF0ZVBvaW50ZXIoZ2V0QWN0dWFsRXZlbnQoaW5wdXQpLCBwcmV2ZW50RGVmYXVsdCk7XG4gICAgfVxuXG4gICAgdGhpcy5pbnB1dE9mZnNldCA9IHt9O1xuICAgIHRoaXMuaW5wdXRPcmlnaW4gPSB7IC4uLnRoaXMuaW5wdXQuc3RhdGUgfTtcbiAgICB0aGlzLmlucHV0LnN0YXJ0KCk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHN0b3AoKSB7XG4gICAgc3VwZXIuc3RvcCgpO1xuICAgIHRoaXMuaW5wdXQuc3RvcCgpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBvblVwZGF0ZSh0cmFjaywgZnJhbWVTdGFtcCwgZWxhcHNlZCkge1xuICAgIHRoaXMuaW5wdXRPZmZzZXQgPSBvZmZzZXQodGhpcy5pbnB1dE9yaWdpbiwgdGhpcy5pbnB1dC5zdGF0ZSk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubnVtVmFsdWVLZXlzOyBpKyspIHtcbiAgICAgIGNvbnN0IGtleSA9IHRoaXMudmFsdWVLZXlzW2ldO1xuXG4gICAgICBpZiAodGhpcy5pbnB1dE9mZnNldC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy52YWx1ZXNba2V5XTtcbiAgICAgICAgY29uc3QgaW5wdXRQcm9wID0gdmFsdWUuaGFzT3duUHJvcGVydHkoJ3dhdGNoJykgPyB2YWx1ZS53YXRjaCA6IGtleTtcblxuICAgICAgICBpZiAodmFsdWUuZGlyZWN0KSB7XG4gICAgICAgICAgdmFsdWUuY3VycmVudCA9IHRoaXMuaW5wdXQuc3RhdGVbaW5wdXRQcm9wXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZS5jdXJyZW50ID0gdmFsdWUuZnJvbSArIHRoaXMuaW5wdXRPZmZzZXRbaW5wdXRQcm9wXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNtb290aCB2YWx1ZSBpZiB3ZSBoYXZlIHNtb290aGluZ1xuICAgICAgICBpZiAodmFsdWUuc21vb3RoKSB7XG4gICAgICAgICAgdmFsdWUuY3VycmVudCA9IHNtb290aCh2YWx1ZS5jdXJyZW50LCB2YWx1ZS5wcmV2LCBlbGFwc2VkLCB2YWx1ZS5zbW9vdGgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cblRyYWNrLnByb3RvdHlwZS5kZWZhdWx0VmFsdWVQcm9wID0gJ3dhdGNoJztcblRyYWNrLnByb3RvdHlwZS5kZWZhdWx0VmFsdWUgPSBBY3Rpb24uZXh0ZW5kRGVmYXVsdFZhbHVlKHtcbiAgZGlyZWN0OiBmYWxzZSxcbiAgZnJvbTogMFxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IFRyYWNrO1xuIl19