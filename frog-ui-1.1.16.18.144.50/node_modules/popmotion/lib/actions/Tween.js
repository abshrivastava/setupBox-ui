'use strict';

exports.__esModule = true;

var _Action2 = require('./Action');

var _Action3 = _interopRequireDefault(_Action2);

var _presetEasing = require('./easing/preset-easing');

var _presetEasing2 = _interopRequireDefault(_presetEasing);

var _utils = require('../inc/utils');

var _calc = require('../inc/calc');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var COUNT = 'Count';
var NEXT_STEPS = {
  loop: 'restart',
  yoyo: 'reverse',
  flip: 'flipValues'
};

var Tween = function (_Action) {
  _inherits(Tween, _Action);

  function Tween() {
    _classCallCheck(this, Tween);

    return _possibleConstructorReturn(this, _Action.apply(this, arguments));
  }

  Tween.prototype.start = function start() {
    this.elapsed = 0;
    this.flipCount = this.yoyoCount = this.loopCount = 0;
    this.isScrubbing = false;

    // Set default `from` if none set
    if (!this.flow) {
      for (var i = 0; i < this.numValueKeys; i++) {
        var key = this.valueKeys[i];
        var value = this.values[key];
        if (value.from === undefined) {
          value.from = 0;
        }
      }
    }

    return _Action.prototype.start.call(this);
  };

  Tween.prototype.onUpdate = function onUpdate(tween, frameStamp, elapsed) {
    var progressTarget = this.playDirection === 1 ? 1 : 0;

    this.ended = true;

    if (!this.isScrubbing) {
      this.elapsed += elapsed * this.dilate * this.playDirection;
    }

    for (var i = 0; i < this.numValueKeys; i++) {
      var key = this.valueKeys[i];
      var value = this.values[key];

      var progress = (0, _calc.restrict)((0, _calc.getProgressFromValue)(this.elapsed - value.delay, 0, value.duration), 0, 1);

      // Mark Tween as NOT ended if still in progress
      if (progress !== progressTarget) {
        this.ended = false;
      }

      // Step progress if we're stepping
      if (value.steps) {
        progress = (0, _calc.stepProgress)(progress, value.steps);
      }

      // Ease progress
      value.current = (0, _calc.ease)(progress, value.from, value.to, value.ease);
    }
  };

  Tween.prototype.onFrameEnd = function onFrameEnd() {
    if (this.ended) {
      var stepTaken = false;

      for (var key in NEXT_STEPS) {
        if (NEXT_STEPS.hasOwnProperty(key)) {
          if ((0, _utils.isNum)(this[key]) && this[key] > this[key + COUNT]) {
            this[key + COUNT]++;
            stepTaken = true;
            this[NEXT_STEPS[key]]();
          }
        }
      }

      if (!stepTaken) {
        this.complete();
      }
    }
  };

  Tween.prototype.flipValues = function flipValues() {
    var values = this.values;

    this.elapsed = this.duration - this.elapsed;

    for (var key in values) {
      if (values.hasOwnProperty(key)) {
        var value = values[key];
        var _ref = [value.from, value.to];
        value.to = _ref[0];
        value.from = _ref[1];
      }
    }

    return this;
  };

  Tween.prototype.reverse = function reverse() {
    this.playDirection *= -1;
    return this;
  };

  Tween.prototype.restart = function restart() {
    this.elapsed = this.playDirection === 1 ? 0 : this.duration;
    this.started = (0, _utils.currentTime)();
    return this;
  };

  Tween.prototype.seek = function seek(progress) {
    this.seekTime(this.duration * progress);
    return this;
  };

  Tween.prototype.seekTime = function seekTime(elapsed) {
    if (!this.isActive || this.isScrubbing) {
      this.once();
      this.isScrubbing = true;
    }

    this.elapsed = elapsed;

    return this;
  };

  return Tween;
}(_Action3.default);

Tween.prototype.defaultValueProp = 'to';
Tween.prototype.defaultValue = _Action3.default.extendDefaultValue({
  delay: 0,
  duration: 300,
  ease: _presetEasing2.default.easeOut,
  elapsed: 0,
  steps: 0,
  to: 0,
  round: false
});
Tween.prototype.defaultProps = _Action3.default.extendDefaultProps({
  blend: false,
  dilate: 1,
  loop: 0,
  yoyo: 0,
  flip: 0,
  loopCount: 0,
  yoyoCount: 0,
  flipCount: 0,
  playDirection: 1,
  isScrubbing: false,
  ended: false,
  elapsed: 0
});

exports.default = Tween;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9hY3Rpb25zL1R3ZWVuLmpzIl0sIm5hbWVzIjpbIkNPVU5UIiwiTkVYVF9TVEVQUyIsImxvb3AiLCJ5b3lvIiwiZmxpcCIsIlR3ZWVuIiwic3RhcnQiLCJlbGFwc2VkIiwiZmxpcENvdW50IiwieW95b0NvdW50IiwibG9vcENvdW50IiwiaXNTY3J1YmJpbmciLCJmbG93IiwiaSIsIm51bVZhbHVlS2V5cyIsImtleSIsInZhbHVlS2V5cyIsInZhbHVlIiwidmFsdWVzIiwiZnJvbSIsInVuZGVmaW5lZCIsIm9uVXBkYXRlIiwidHdlZW4iLCJmcmFtZVN0YW1wIiwicHJvZ3Jlc3NUYXJnZXQiLCJwbGF5RGlyZWN0aW9uIiwiZW5kZWQiLCJkaWxhdGUiLCJwcm9ncmVzcyIsImRlbGF5IiwiZHVyYXRpb24iLCJzdGVwcyIsImN1cnJlbnQiLCJ0byIsImVhc2UiLCJvbkZyYW1lRW5kIiwic3RlcFRha2VuIiwiaGFzT3duUHJvcGVydHkiLCJjb21wbGV0ZSIsImZsaXBWYWx1ZXMiLCJyZXZlcnNlIiwicmVzdGFydCIsInN0YXJ0ZWQiLCJzZWVrIiwic2Vla1RpbWUiLCJpc0FjdGl2ZSIsIm9uY2UiLCJwcm90b3R5cGUiLCJkZWZhdWx0VmFsdWVQcm9wIiwiZGVmYXVsdFZhbHVlIiwiZXh0ZW5kRGVmYXVsdFZhbHVlIiwiZWFzZU91dCIsInJvdW5kIiwiZGVmYXVsdFByb3BzIiwiZXh0ZW5kRGVmYXVsdFByb3BzIiwiYmxlbmQiXSwibWFwcGluZ3MiOiI7Ozs7QUFBQTs7OztBQUNBOzs7O0FBQ0E7O0FBQ0E7Ozs7Ozs7Ozs7QUFFQSxJQUFNQSxRQUFRLE9BQWQ7QUFDQSxJQUFNQyxhQUFhO0FBQ2pCQyxRQUFNLFNBRFc7QUFFakJDLFFBQU0sU0FGVztBQUdqQkMsUUFBTTtBQUhXLENBQW5COztJQU1NQyxLO1lBQUFBLEs7O1dBQUFBLEs7MEJBQUFBLEs7Ozs7O0FBQUFBLE8sV0FDSkMsSyxvQkFBUTtBQUNOLFNBQUtDLE9BQUwsR0FBZSxDQUFmO0FB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O0FBTXZERSxNQUFJLENBTm1EO0FBT3ZEbUIsU0FBTztBQVBnRCxDQUExQixDQUEvQjtBQVNBL0MsTUFBTTBDLFNBQU4sQ0FBZ0JNLFlBQWhCLEdBQStCLGlCQUFPQyxrQkFBUCxDQUEwQjtBQUN2REMsU0FBTyxLQURnRDtBQUV2RDVCLFVBQVEsQ0FGK0M7QUFHdkR6QixRQUFNLENBSGlEO0FBSXZEQyxRQUFNLENBSmlEO0FBS3ZEQyxRQUFNLENBTGlEO0FBTXZETSxhQUFXLENBTjRDO0FBT3ZERCxhQUFXLENBUDRDO0FBUXZERCxhQUFXLENBUjRDO0FBU3ZEaUIsaUJBQWUsQ0FUd0M7QUFVdkRkLGVBQWEsS0FWMEM7QUFXdkRlLFNBQU8sS0FYZ0Q7QUFZdkRuQixXQUFTO0FBWjhDLENBQTFCLENBQS9COztrQkFlZUYsSyIsImZpbGUiOiJUd2Vlbi5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBBY3Rpb24gZnJvbSAnLi9BY3Rpb24nO1xuaW1wb3J0IGVhc2luZyBmcm9tICcuL2Vhc2luZy9wcmVzZXQtZWFzaW5nJztcbmltcG9ydCB7IGN1cnJlbnRUaW1lLCBpc051bSB9IGZyb20gJy4uL2luYy91dGlscyc7XG5pbXBvcnQgeyBlYXNlLCByZXN0cmljdCwgZ2V0UHJvZ3Jlc3NGcm9tVmFsdWUsIHN0ZXBQcm9ncmVzcyB9IGZyb20gJy4uL2luYy9jYWxjJztcblxuY29uc3QgQ09VTlQgPSAnQ291bnQnO1xuY29uc3QgTkVYVF9TVEVQUyA9IHtcbiAgbG9vcDogJ3Jlc3RhcnQnLFxuICB5b3lvOiAncmV2ZXJzZScsXG4gIGZsaXA6ICdmbGlwVmFsdWVzJ1xufTtcblxuY2xhc3MgVHdlZW4gZXh0ZW5kcyBBY3Rpb24ge1xuICBzdGFydCgpIHtcbiAgICB0aGlzLmVsYXBzZWQgPSAwO1xuICAgIHRoaXMuZmxpcENvdW50ID0gdGhpcy55b3lvQ291bnQgPSB0aGlzLmxvb3BDb3VudCA9IDA7XG4gICAgdGhpcy5pc1NjcnViYmluZyA9IGZhbHNlO1xuXG4gICAgLy8gU2V0IGRlZmF1bHQgYGZyb21gIGlmIG5vbmUgc2V0XG4gICAgaWYgKCF0aGlzLmZsb3cpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5udW1WYWx1ZUtleXM7IGkrKykge1xuICAgICAgICBjb25zdCBrZXkgPSB0aGlzLnZhbHVlS2V5c1tpXTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLnZhbHVlc1trZXldO1xuICAgICAgICBpZiAodmFsdWUuZnJvbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdmFsdWUuZnJvbSA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc3VwZXIuc3RhcnQoKTtcbiAgfVxuXG4gIG9uVXBkYXRlKHR3ZWVuLCBmcmFtZVN0YW1wLCBlbGFwc2VkKSB7XG4gICAgY29uc3QgcHJvZ3Jlc3NUYXJnZXQgPSAodGhpcy5wbGF5RGlyZWN0aW9uID09PSAxKSA/IDEgOiAwO1xuXG4gICAgdGhpcy5lbmRlZCA9IHRydWU7XG5cbiAgICBpZiAoIXRoaXMuaXNTY3J1YmJpbmcpIHtcbiAgICAgIHRoaXMuZWxhcHNlZCArPSAoZWxhcHNlZCAqIHRoaXMuZGlsYXRlKSAqIHRoaXMucGxheURpcmVjdGlvbjtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubnVtVmFsdWVLZXlzOyBpKyspIHtcbiAgICAgIGNvbnN0IGtleSA9IHRoaXMudmFsdWVLZXlzW2ldO1xuICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLnZhbHVlc1trZXldO1xuXG4gICAgICBsZXQgcHJvZ3Jlc3MgPSByZXN0cmljdChnZXRQcm9ncmVzc0Zyb21WYWx1ZSh0aGlzLmVsYXBzZWQgLSB2YWx1ZS5kZWxheSwgMCwgdmFsdWUuZHVyYXRpb24pLCAwLCAxKTtcblxuICAgICAgLy8gTWFyayBUd2VlbiBhcyBOT1QgZW5kZWQgaWYgc3RpbGwgaW4gcHJvZ3Jlc3NcbiAgICAgIGlmIChwcm9ncmVzcyAhPT0gcHJvZ3Jlc3NUYXJnZXQpIHtcbiAgICAgICAgdGhpcy5lbmRlZCA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvLyBTdGVwIHByb2dyZXNzIGlmIHdlJ3JlIHN0ZXBwaW5nXG4gICAgICBpZiAodmFsdWUuc3RlcHMpIHtcbiAgICAgICAgcHJvZ3Jlc3MgPSBzdGVwUHJvZ3Jlc3MocHJvZ3Jlc3MsIHZhbHVlLnN0ZXBzKTtcbiAgICAgIH1cblxuICAgICAgLy8gRWFzZSBwcm9ncmVzc1xuICAgICAgdmFsdWUuY3VycmVudCA9IGVhc2UocHJvZ3Jlc3MsIHZhbHVlLmZyb20sIHZhbHVlLnRvLCB2YWx1ZS5lYXNlKTtcbiAgICB9XG4gIH1cblxuICBvbkZyYW1lRW5kKCkge1xuICAgIGlmICh0aGlzLmVuZGVkKSB7XG4gICAgICBsZXQgc3RlcFRha2VuID0gZmFsc2U7XG5cbiAgICAgIGZvciAobGV0IGtleSBpbiBORVhUX1NURVBTKSB7XG4gICAgICAgIGlmIChORVhUX1NURVBTLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICBpZiAoaXNOdW0odGhpc1trZXldKSAmJiB0aGlzW2tleV0gPiB0aGlzW2tleSArIENPVU5UXSkge1xuICAgICAgICAgICAgdGhpc1trZXkgKyBDT1VOVF0rKztcbiAgICAgICAgICAgIHN0ZXBUYWtlbiA9IHRydWU7XG4gICAgICAgICAgICB0aGlzW05FWFRfU1RFUFNba2V5XV0oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFzdGVwVGFrZW4pIHtcbiAgICAgICAgdGhpcy5jb21wbGV0ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZsaXBWYWx1ZXMoKSB7XG4gICAgY29uc3QgdmFsdWVzID0gdGhpcy52YWx1ZXM7XG5cbiAgICB0aGlzLmVsYXBzZWQgPSB0aGlzLmR1cmF0aW9uIC0gdGhpcy5lbGFwc2VkO1xuXG4gICAgZm9yIChsZXQga2V5IGluIHZhbHVlcykge1xuICAgICAgaWYgKHZhbHVlcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdmFsdWVzW2tleV07XG4gICAgICAgIFt2YWx1ZS50bywgdmFsdWUuZnJvbV0gPSBbdmFsdWUuZnJvbSwgdmFsdWUudG9dO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgcmV2ZXJzZSgpIHtcbiAgICB0aGlzLnBsYXlEaXJlY3Rpb24gKj0gLTE7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICByZXN0YXJ0KCkge1xuICAgIHRoaXMuZWxhcHNlZCA9ICh0aGlzLnBsYXlEaXJlY3Rpb24gPT09IDEpID8gMCA6IHRoaXMuZHVyYXRpb247XG4gICAgdGhpcy5zdGFydGVkID0gY3VycmVudFRpbWUoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHNlZWsocHJvZ3Jlc3MpIHtcbiAgICB0aGlzLnNlZWtUaW1lKHRoaXMuZHVyYXRpb24gKiBwcm9ncmVzcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBzZWVrVGltZShlbGFwc2VkKSB7XG4gICAgaWYgKCF0aGlzLmlzQWN0aXZlIHx8IHRoaXMuaXNTY3J1YmJpbmcpIHtcbiAgICAgIHRoaXMub25jZSgpO1xuICAgICAgdGhpcy5pc1NjcnViYmluZyA9IHRydWU7XG4gICAgfVxuXG4gICAgdGhpcy5lbGFwc2VkID0gZWxhcHNlZDtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG59XG5cblR3ZWVuLnByb3RvdHlwZS5kZWZhdWx0VmFsdWVQcm9wID0gJ3RvJztcblR3ZWVuLnByb3RvdHlwZS5kZWZhdWx0VmFsdWUgPSBBY3Rpb24uZXh0ZW5kRGVmYXVsdFZhbHVlKHtcbiAgZGVsYXk6IDAsXG4gIGR1cmF0aW9uOiAzMDAsXG4gIGVhc2U6IGVhc2luZy5lYXNlT3V0LFxuICBlbGFwc2VkOiAwLFxuICBzdGVwczogMCxcbiAgdG86IDAsXG4gIHJvdW5kOiBmYWxzZVxufSk7XG5Ud2Vlbi5wcm90b3R5cGUuZGVmYXVsdFByb3BzID0gQWN0aW9uLmV4dGVuZERlZmF1bHRQcm9wcyh7XG4gIGJsZW5kOiBmYWxzZSxcbiAgZGlsYXRlOiAxLFxuICBsb29wOiAwLFxuICB5b3lvOiAwLFxuICBmbGlwOiAwLFxuICBsb29wQ291bnQ6IDAsXG4gIHlveW9Db3VudDogMCxcbiAgZmxpcENvdW50OiAwLFxuICBwbGF5RGlyZWN0aW9uOiAxLFxuICBpc1NjcnViYmluZzogZmFsc2UsXG4gIGVuZGVkOiBmYWxzZSxcbiAgZWxhcHNlZDogMFxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IFR3ZWVuO1xuIl19