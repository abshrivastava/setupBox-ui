'use strict';

exports.__esModule = true;

var _Action2 = require('./Action');

var _Action3 = _interopRequireDefault(_Action2);

var _calc = require('../inc/calc');

var _utils = require('../inc/utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Physics = function (_Action) {
  _inherits(Physics, _Action);

  function Physics() {
    _classCallCheck(this, Physics);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = _possibleConstructorReturn(this, _Action.call.apply(_Action, [this].concat(args)));

    _this.inactiveFrames = 0;
    _this.calculatesVelocity = true;
    return _this;
  }

  Physics.prototype.onUpdate = function onUpdate(physics, frameStamp, elapsed) {
    this.hasChanged = false;

    for (var i = 0; i < this.numValueKeys; i++) {
      var key = this.valueKeys[i];
      var value = this.values[key];

      // Apply acceleration
      value.velocity += (0, _calc.speedPerFrame)(value.acceleration, elapsed);

      // Apply friction
      value.velocity *= Math.pow(1 - value.friction, elapsed / 100);

      // Apply spring
      if (value.spring && (0, _utils.isNum)(value.to)) {
        var distanceToTarget = value.to - value.current;
        value.velocity += distanceToTarget * (0, _calc.speedPerFrame)(value.spring, elapsed);
      }

      // Apply latest velocity
      value.current += (0, _calc.speedPerFrame)(value.velocity, elapsed);

      // Detect bounce
      if (value.min !== undefined && value.current < value.min || value.max !== undefined && value.current > value.max) {
        value.velocity *= -value.bounce;
      }

      // Check if value has changed
      if (Math.abs(value.velocity) >= value.stopSpeed) {
        this.hasChanged = true;
      }

      if (value.spring && !this.hasChanged) {
        value.current = value.to;
      }
    }
  };

  Physics.prototype.onFrameEnd = function onFrameEnd() {
    if (this.maxInactiveFrames !== Infinity) {
      this.inactiveFrames = this.hasChanged ? 1 : this.inactiveFrames + 1;

      if (this.inactiveFrames >= this.maxInactiveFrames) {
        this.complete();
      }
    }
  };

  return Physics;
}(_Action3.default);

Physics.prototype.defaultValueProp = 'velocity';
Physics.prototype.defaultValue = _Action3.default.extendDefaultValue({
  acceleration: 0, // [number]: Acceleration to apply to value, in units per second
  bounce: 0, // [number]: Factor to multiply velocity by on bounce
  spring: 0, // [number]: Spring strength during 'string'
  stopSpeed: 0.001, // [number]: Stop simulation under this speed
  friction: 0 // [number]: Friction to apply per frame, 0-1
});
Physics.prototype.defaultProps = _Action3.default.extendDefaultProps({
  maxInactiveFrames: 3
});

exports.default = Physics;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9hY3Rpb25zL1BoeXNpY3MuanMiXSwibmFtZXMiOlsiUGh5c2ljcyIsImFyZ3MiLCJpbmFjdGl2ZUZyYW1lcyIsImNhbGN1bGF0ZXNWZWxvY2l0eSIsIm9uVXBkYXRlIiwicGh5c2ljcyIsImZyYW1lU3RhbXAiLCJlbGFwc2VkIiwiaGFzQ2hhbmdlZCIsImkiLCJudW1WYWx1ZUtleXMiLCJrZXkiLCJ2YWx1ZUtleXMiLCJ2YWx1ZSIsInZhbHVlcyIsInZlbG9jaXR5IiwiYWNjZWxlcmF0aW9uIiwiZnJpY3Rpb24iLCJzcHJpbmciLCJ0byIsImRpc3RhbmNlVG9UYXJnZXQiLCJjdXJyZW50IiwibWluIiwidW5kZWZpbmVkIiwibWF4IiwiYm91bmNlIiwiTWF0aCIsImFicyIsInN0b3BTcGVlZCIsIm9uRnJhbWVFbmQiLCJtYXhJbmFjdGl2ZUZyYW1lcyIsIkluZmluaXR5IiwiY29tcGxldGUiLCJwcm90b3R5cGUiLCJkZWZhdWx0VmFsdWVQcm9wIiwiZGVmYXVsdFZhbHVlIiwiZXh0ZW5kRGVmYXVsdFZhbHVlIiwiZGVmYXVsdFByb3BzIiwiZXh0ZW5kRGVmYXVsdFByb3BzIl0sIm1hcHBpbmdzIjoiOzs7O0FBQUE7Ozs7QUFDQTs7QUFDQTs7Ozs7Ozs7OztJQUVNQSxPO1lBQUFBLE87O0FBQ0osV0FESUEsT0FDSixHQUFxQjtBQUFBLDBCQURqQkEsT0FDaUI7O0FBQUEsc0NBQU5DLElBQU07QUFBTkEsVUFBTTtBQUFBOztBQUFBLGlEQUNuQiwwQ0FBU0EsSUFBVCxFQURtQjs7QUFFbkIsVUFBS0MsY0FBTCxHQUFzQixDQUF0QjtBQUNBLFVBQUtDLGtCQUFMLEdBQTBCLElBQTFCO0FBSG1CO0FBSXBCOztBQUxHSCxTLFdBT0pJLFEscUJBQVNDLE8sRUFBU0MsVSxFQUFZQyxPLEVBQVM7QUFDckMsU0FBS0MsVUFBTCxHQUFrQixLQUFsQjs7QUFFQSxTQUFLLElBQUlDLElBQUksQ0FBYixFQUFnQkEsSUFBSSxLQUFLQyxZQUF6QixFQUF1Q0QsR0FBdkMsRUFBNEM7QUFDMUMsVUFBTUUsTUFBTSxLQUFLQyxTQUFMLENBQWVILENBQWYsQ0FBWjtBQUNBLFVBQU1JLFFBQVEsS0FBS0MsTUFBTCxDQUFZSCxHQUFaLENBQWQ7O0FBRUE7QUFDQUUsWUFBTUUsUUFBTixJQUFrQix5QkFBY0YsTUFBTUcsWUFBcEIsRUFBa0NULE9BQWxDLENBQWxCOztBQUVBO0FBQ0FNLFlBQU1FLFFBQU4sYUFBbUIsSUFBSUYsTUFBTUksUUFBN0IsRUFBMkNWLFVBQVUsR0FBckQ7O0FBRUE7QUFDQSxVQUFJTSxNQUFNSyxNQUFOLElBQWdCLGtCQUFNTCxNQUFNTSxFQUFaLENBQXBCLEVBQXFDO0FBQ25DLFlBQU1DLG1CQUFtQlAsTUFBTU0sRUFBTixHQUFXTixNQUFNUSxPQUExQztBQUNBUixjQUFNRSxRQUFOLElBQWtCSyxtQkFBbUIseUJBQWNQLE1BQU1LLE1BQXBCLEVBQTRCWCxPQUE1QixDQUFyQztBQUNEOztBQUVEO0FBQ0FNLFlBQU1RLE9BQU4sSUFBaUIseUJBQWNSLE1BQU1FLFFBQXBCLEVBQThCUixPQUE5QixDQUFqQjs7QUFFQTtBQUNBLFVBQUtNLE1BQU1TLEdBQU4sS0FBY0MsU0FBZCxJQUEyQlYsTUFBTVEsT0FBTixHQUFnQlIsTUFBTVMsR0FBbEQsSUFBMkRULE1BQU1XLEdBQU4sS0FBY0QsU0FBZCxJQUEyQlYsTUFBTVEsT0FBTixHQUFnQlIsTUFBTVcsR0FBaEgsRUFBc0g7QUFDcEhYLGNBQU1FLFFBQU4sSUFBa0IsQ0FBRUYsTUFBTVksTUFBMUI7QUFDRDs7QUFFRDtBQUNBLFVBQUlDLEtBQUtDLEdBQUwsQ0FBU2QsTUFBTUUsUUFBZixLQUE0QkYsTUFBTWUsU0FBdEMsRUFBaUQ7QUFDL0MsYUFBS3BCLFVBQUwsR0FBa0IsSUFBbEI7QUFDRDs7QUFFRCxVQUFJSyxNQUFNSyxNQUFOLElBQWdCLENBQUMsS0FBS1YsVUFBMUIsRUFBc0M7QUFDcENLLGNBQU1RLE9BQU4sR0FBZ0JSLE1BQU1NLEVBQXRCO0FBQ0Q7QUFDRjtBQUNGLEc7O0FBM0NHbkIsUyxXQTZDSjZCLFUseUJBQWE7QUFDWCxRQUFJLEtBQUtDLGlCQUFMLEtBQTJCQyxRQUEvQixFQUF5QztBQUN2QyxXQUFLN0IsY0FBTCxHQUFzQixLQUFLTSxVQUFMLEdBQWtCLENBQWxCLEdBQXNCLEtBQUtOLGNBQUwsR0FBc0IsQ0FBbEU7O0FBRUEsVUFBSSxLQUFLQSxjQUFMLElBQXVCLEtBQUs0QixpQkFBaEMsRUFBbUQ7QUFDakQsYUFBS0UsUUFBTDtBQUNEO0FBQ0Y7QUFDRixHOztTQXJER2hDLE87OztBQXdETkEsUUFBUWlDLFNBQVIsQ0FBa0JDLGdCQUFsQixHQUFxQyxVQUFyQztBQUNBbEMsUUFBUWlDLFNBQVIsQ0FBa0JFLFlBQWxCLEdBQWlDLGlCQUFPQyxrQkFBUCxDQUEwQjtBQUN6RHBCLGdCQUFjLENBRDJDLEVBQ3hDO0FBQ2pCUyxVQUFRLENBRmlELEVBRTlDO0FBQ1hQLFVBQVEsQ0FIaUQsRUFHOUM7QUFDWFUsYUFBVyxLQUo4QyxFQUl2QztBQUNsQlgsWUFBVSxDQUwrQyxDQUs3QztBQUw2QyxDQUExQixDQUFqQztBQU9BakIsUUFBUWlDLFNBQVIsQ0FBa0JJLFlBQWxCLEdBQWlDLGlCQUFPQyxrQkFBUCxDQUEwQjtBQUN6RFIscUJBQW1CO0FBRHNDLENBQTFCLENBQWpDOztrQkFJZTlCLE8iLCJmaWxlIjoiUGh5c2ljcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBBY3Rpb24gZnJvbSAnLi9BY3Rpb24nO1xuaW1wb3J0IHsgc3BlZWRQZXJGcmFtZSB9IGZyb20gJy4uL2luYy9jYWxjJztcbmltcG9ydCB7IGlzTnVtIH0gZnJvbSAnLi4vaW5jL3V0aWxzJztcblxuY2xhc3MgUGh5c2ljcyBleHRlbmRzIEFjdGlvbiB7XG4gIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKTtcbiAgICB0aGlzLmluYWN0aXZlRnJhbWVzID0gMDtcbiAgICB0aGlzLmNhbGN1bGF0ZXNWZWxvY2l0eSA9IHRydWU7XG4gIH1cblxuICBvblVwZGF0ZShwaHlzaWNzLCBmcmFtZVN0YW1wLCBlbGFwc2VkKSB7XG4gICAgdGhpcy5oYXNDaGFuZ2VkID0gZmFsc2U7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubnVtVmFsdWVLZXlzOyBpKyspIHtcbiAgICAgIGNvbnN0IGtleSA9IHRoaXMudmFsdWVLZXlzW2ldO1xuICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLnZhbHVlc1trZXldO1xuXG4gICAgICAvLyBBcHBseSBhY2NlbGVyYXRpb25cbiAgICAgIHZhbHVlLnZlbG9jaXR5ICs9IHNwZWVkUGVyRnJhbWUodmFsdWUuYWNjZWxlcmF0aW9uLCBlbGFwc2VkKTtcblxuICAgICAgLy8gQXBwbHkgZnJpY3Rpb25cbiAgICAgIHZhbHVlLnZlbG9jaXR5ICo9ICgxIC0gdmFsdWUuZnJpY3Rpb24pICoqIChlbGFwc2VkIC8gMTAwKTtcblxuICAgICAgLy8gQXBwbHkgc3ByaW5nXG4gICAgICBpZiAodmFsdWUuc3ByaW5nICYmIGlzTnVtKHZhbHVlLnRvKSkge1xuICAgICAgICBjb25zdCBkaXN0YW5jZVRvVGFyZ2V0ID0gdmFsdWUudG8gLSB2YWx1ZS5jdXJyZW50O1xuICAgICAgICB2YWx1ZS52ZWxvY2l0eSArPSBkaXN0YW5jZVRvVGFyZ2V0ICogc3BlZWRQZXJGcmFtZSh2YWx1ZS5zcHJpbmcsIGVsYXBzZWQpO1xuICAgICAgfVxuXG4gICAgICAvLyBBcHBseSBsYXRlc3QgdmVsb2NpdHlcbiAgICAgIHZhbHVlLmN1cnJlbnQgKz0gc3BlZWRQZXJGcmFtZSh2YWx1ZS52ZWxvY2l0eSwgZWxhcHNlZCk7XG5cbiAgICAgIC8vIERldGVjdCBib3VuY2VcbiAgICAgIGlmICgodmFsdWUubWluICE9PSB1bmRlZmluZWQgJiYgdmFsdWUuY3VycmVudCA8IHZhbHVlLm1pbikgfHwgKHZhbHVlLm1heCAhPT0gdW5kZWZpbmVkICYmIHZhbHVlLmN1cnJlbnQgPiB2YWx1ZS5tYXgpKSB7XG4gICAgICAgIHZhbHVlLnZlbG9jaXR5ICo9IC0gdmFsdWUuYm91bmNlO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBDaGVjayBpZiB2YWx1ZSBoYXMgY2hhbmdlZFxuICAgICAgaWYgKE1hdGguYWJzKHZhbHVlLnZlbG9jaXR5KSA+PSB2YWx1ZS5zdG9wU3BlZWQpIHtcbiAgICAgICAgdGhpcy5oYXNDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHZhbHVlLnNwcmluZyAmJiAhdGhpcy5oYXNDaGFuZ2VkKSB7XG4gICAgICAgIHZhbHVlLmN1cnJlbnQgPSB2YWx1ZS50bztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBvbkZyYW1lRW5kKCkge1xuICAgIGlmICh0aGlzLm1heEluYWN0aXZlRnJhbWVzICE9PSBJbmZpbml0eSkge1xuICAgICAgdGhpcy5pbmFjdGl2ZUZyYW1lcyA9IHRoaXMuaGFzQ2hhbmdlZCA/IDEgOiB0aGlzLmluYWN0aXZlRnJhbWVzICsgMTtcblxuICAgICAgaWYgKHRoaXMuaW5hY3RpdmVGcmFtZXMgPj0gdGhpcy5tYXhJbmFjdGl2ZUZyYW1lcykge1xuICAgICAgICB0aGlzLmNvbXBsZXRlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cblBoeXNpY3MucHJvdG90eXBlLmRlZmF1bHRWYWx1ZVByb3AgPSAndmVsb2NpdHknO1xuUGh5c2ljcy5wcm90b3R5cGUuZGVmYXVsdFZhbHVlID0gQWN0aW9uLmV4dGVuZERlZmF1bHRWYWx1ZSh7XG4gIGFjY2VsZXJhdGlvbjogMCwgLy8gW251bWJlcl06IEFjY2VsZXJhdGlvbiB0byBhcHBseSB0byB2YWx1ZSwgaW4gdW5pdHMgcGVyIHNlY29uZFxuICBib3VuY2U6IDAsIC8vIFtudW1iZXJdOiBGYWN0b3IgdG8gbXVsdGlwbHkgdmVsb2NpdHkgYnkgb24gYm91bmNlXG4gIHNwcmluZzogMCwgLy8gW251bWJlcl06IFNwcmluZyBzdHJlbmd0aCBkdXJpbmcgJ3N0cmluZydcbiAgc3RvcFNwZWVkOiAwLjAwMSwgLy8gW251bWJlcl06IFN0b3Agc2ltdWxhdGlvbiB1bmRlciB0aGlzIHNwZWVkXG4gIGZyaWN0aW9uOiAwIC8vIFtudW1iZXJdOiBGcmljdGlvbiB0byBhcHBseSBwZXIgZnJhbWUsIDAtMVxufSk7XG5QaHlzaWNzLnByb3RvdHlwZS5kZWZhdWx0UHJvcHMgPSBBY3Rpb24uZXh0ZW5kRGVmYXVsdFByb3BzKHtcbiAgbWF4SW5hY3RpdmVGcmFtZXM6IDNcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBQaHlzaWNzO1xuIl19