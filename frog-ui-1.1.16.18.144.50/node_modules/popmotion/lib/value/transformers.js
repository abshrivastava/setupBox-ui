'use strict';

exports.__esModule = true;
exports.steppedMotion = exports.restrictBetween = exports.restrictOver = exports.restrictUnder = exports.interpolate = exports.compose = exports.appendUnit = undefined;

var _calc = require('../inc/calc');

/**
 * Append Unit
 * Creates a function that will append the unit to a given value
 * appendUnit('px')(20) -> '20px'
 * @param  {string} unit)
 * @return {number}
 */
var appendUnit = exports.appendUnit = function (unit) {
  return function (v) {
    return '' + v + unit;
  };
};

/**
 * Compose
 * Compose other transformers to run linearily
 * compose(min(20), max(40))
 * @param  {...functions} transformers
 * @return {function}
 */
var compose = exports.compose = function () {
  for (var _len = arguments.length, transformers = Array(_len), _key = 0; _key < _len; _key++) {
    transformers[_key] = arguments[_key];
  }

  var numTransformers = transformers.length;
  var i = 0;

  return function (v, value) {
    for (i = 0; i < numTransformers; i++) {
      v = transformers[i](v, value);
    }

    return v;
  };
};

var interpolate = exports.interpolate = function (input, output, rangeEasing) {
  var rangeLength = input.length;
  var finalIndex = rangeLength - 1;

  return function (v) {
    // If value outside minimum range, quickly return
    if (v <= input[0]) {
      return output[0];
    }

    // If value outside maximum range, quickly return
    if (v >= input[finalIndex]) {
      return output[finalIndex];
    }

    var i = 0;

    // Find index of range start
    for (; i < rangeLength; i++) {
      if (input[i] > v || i === finalIndex) {
        break;
      }
    }

    var progressInRange = (0, _calc.getProgressFromValue)(v, input[i], input[i + 1]);
    var easedProgress = rangeEasing ? rangeEasing[i](progressInRange) : progressInRange;
    return (0, _calc.getValueFromProgress)(easedProgress, output[i], output[i + 1]);
  };
};

/**
 * Restrict value between
 * Creates a function that will restrict a given value between `min` and `max`
 * @param  {number} min
 * @param  {number} max
 * @return {number}
 */
var restrictUnder = exports.restrictUnder = function (max) {
  return function (v) {
    return Math.min(v, max);
  };
};
var restrictOver = exports.restrictOver = function (min) {
  return function (v) {
    return Math.max(v, min);
  };
};
var restrictBetween = exports.restrictBetween = function (min, max) {
  return compose(restrictOver(min), restrictUnder(max));
};

var steppedMotion = exports.steppedMotion = function (min, max) {
  return function (v) {};
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy92YWx1ZS90cmFuc2Zvcm1lcnMuanMiXSwibmFtZXMiOlsiYXBwZW5kVW5pdCIsInVuaXQiLCJ2IiwiY29tcG9zZSIsInRyYW5zZm9ybWVycyIsIm51bVRyYW5zZm9ybWVycyIsImxlbmd0aCIsImkiLCJ2YWx1ZSIsImludGVycG9sYXRlIiwiaW5wdXQiLCJvdXRwdXQiLCJyYW5nZUVhc2luZyIsInJhbmdlTGVuZ3RoIiwiZmluYWxJbmRleCIsInByb2dyZXNzSW5SYW5nZSIsImVhc2VkUHJvZ3Jlc3MiLCJyZXN0cmljdFVuZGVyIiwibWF4IiwiTWF0aCIsIm1pbiIsInJlc3RyaWN0T3ZlciIsInJlc3RyaWN0QmV0d2VlbiIsInN0ZXBwZWRNb3Rpb24iXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7O0FBRUE7Ozs7Ozs7QUFPTyxJQUFNQSxrQ0FBYSxVQUFDQyxJQUFEO0FBQUEsU0FBVSxVQUFDQyxDQUFEO0FBQUEsZ0JBQVVBLENBQVYsR0FBY0QsSUFBZDtBQUFBLEdBQVY7QUFBQSxDQUFuQjs7QUFFUDs7Ozs7OztBQU9PLElBQU1FLDRCQUFVLFlBQXFCO0FBQUEsb0NBQWpCQyxZQUFpQjtBQUFqQkEsZ0JBQWlCO0FBQUE7O0FBQzFDLE1BQU1DLGtCQUFrQkQsYUFBYUUsTUFBckM7QUFDQSxNQUFJQyxJQUFJLENBQVI7O0FBRUEsU0FBTyxVQUFDTCxDQUFELEVBQUlNLEtBQUosRUFBYztBQUNuQixTQUFLRCxJQUFJLENBQVQsRUFBWUEsSUFBSUYsZUFBaEIsRUFBaUNFLEdBQWpDLEVBQXNDO0FBQ3BDTCxVQUFJRSxhQUFhRyxDQUFiLEVBQWdCTCxDQUFoQixFQUFtQk0sS0FBbkIsQ0FBSjtBQUNEOztBQUVELFdBQU9OLENBQVA7QUFDRCxHQU5EO0FBT0QsQ0FYTTs7QUFhQSxJQUFNTyxvQ0FBYyxVQUFDQyxLQUFELEVBQVFDLE1BQVIsRUFBZ0JDLFdBQWhCLEVBQWdDO0FBQ3pELE1BQU1DLGNBQWNILE1BQU1KLE1BQTFCO0FBQ0EsTUFBTVEsYUFBYUQsY0FBYyxDQUFqQzs7QUFFQSxTQUFPLFVBQUNYLENBQUQsRUFBTztBQUNaO0FBQ0EsUUFBSUEsS0FBS1EsTUFBTSxDQUFOLENBQVQsRUFBbUI7QUFDakIsYUFBT0MsT0FBTyxDQUFQLENBQVA7QUFDRDs7QUFFRDtBQUNBLFFBQUlULEtBQUtRLE1BQU1JLFVBQU4sQ0FBVCxFQUE0QjtBQUMxQixhQUFPSCxPQUFPRyxVQUFQLENBQVA7QUFDRDs7QUFFRCxRQUFJUCxJQUFJLENBQVI7O0FBRUE7QUFDQSxXQUFPQSxJQUFJTSxXQUFYLEVBQXdCTixHQUF4QixFQUE2QjtBQUMzQixVQUFJRyxNQUFNSCxDQUFOLElBQVdMLENBQVgsSUFBZ0JLLE1BQU1PLFVBQTFCLEVBQXNDO0FBQ3BDO0FBQ0Q7QUFDRjs7QUFFRCxRQUFNQyxrQkFBa0IsZ0NBQXFCYixDQUFyQixFQUF3QlEsTUFBTUgsQ0FBTixDQUF4QixFQUFrQ0csTUFBTUgsSUFBSSxDQUFWLENBQWxDLENBQXhCO0FBQ0EsUUFBTVMsZ0JBQWlCSixXQUFELEdBQWdCQSxZQUFZTCxDQUFaLEVBQWVRLGVBQWYsQ0FBaEIsR0FBa0RBLGVBQXhFO0FBQ0EsV0FBTyxnQ0FBcUJDLGFBQXJCLEVBQW9DTCxPQUFPSixDQUFQLENBQXBDLEVBQStDSSxPQUFPSixJQUFJLENBQVgsQ0FBL0MsQ0FBUDtBQUNELEdBdkJEO0FBd0JELENBNUJNOztBQThCUDs7Ozs7OztBQU9PLElBQU1VLHdDQUFnQixVQUFDQyxHQUFEO0FBQUEsU0FBUyxVQUFDaEIsQ0FBRDtBQUFBLFdBQU9pQixLQUFLQyxHQUFMLENBQVNsQixDQUFULEVBQVlnQixHQUFaLENBQVA7QUFBQSxHQUFUO0FBQUEsQ0FBdEI7QUFDQSxJQUFNRyxzQ0FBZSxVQUFDRCxHQUFEO0FBQUEsU0FBUyxVQUFDbEIsQ0FBRDtBQUFBLFdBQU9pQixLQUFLRCxHQUFMLENBQVNoQixDQUFULEVBQVlrQixHQUFaLENBQVA7QUFBQSxHQUFUO0FBQUEsQ0FBckI7QUFDQSxJQUFNRSw0Q0FBa0IsVUFBQ0YsR0FBRCxFQUFNRixHQUFOO0FBQUEsU0FBY2YsUUFBUWtCLGFBQWFELEdBQWIsQ0FBUixFQUEyQkgsY0FBY0MsR0FBZCxDQUEzQixDQUFkO0FBQUEsQ0FBeEI7O0FBRUEsSUFBTUssd0NBQWdCLFVBQUNILEdBQUQsRUFBTUYsR0FBTjtBQUFBLFNBQWMsVUFBQ2hCLENBQUQsRUFBTyxDQUVqRCxDQUY0QjtBQUFBLENBQXRCIiwiZmlsZSI6InRyYW5zZm9ybWVycy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGdldFByb2dyZXNzRnJvbVZhbHVlLCBnZXRWYWx1ZUZyb21Qcm9ncmVzcyB9IGZyb20gJy4uL2luYy9jYWxjJztcblxuLyoqXG4gKiBBcHBlbmQgVW5pdFxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBhcHBlbmQgdGhlIHVuaXQgdG8gYSBnaXZlbiB2YWx1ZVxuICogYXBwZW5kVW5pdCgncHgnKSgyMCkgLT4gJzIwcHgnXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHVuaXQpXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBhcHBlbmRVbml0ID0gKHVuaXQpID0+ICh2KSA9PiBgJHt2fSR7dW5pdH1gO1xuXG4vKipcbiAqIENvbXBvc2VcbiAqIENvbXBvc2Ugb3RoZXIgdHJhbnNmb3JtZXJzIHRvIHJ1biBsaW5lYXJpbHlcbiAqIGNvbXBvc2UobWluKDIwKSwgbWF4KDQwKSlcbiAqIEBwYXJhbSAgey4uLmZ1bmN0aW9uc30gdHJhbnNmb3JtZXJzXG4gKiBAcmV0dXJuIHtmdW5jdGlvbn1cbiAqL1xuZXhwb3J0IGNvbnN0IGNvbXBvc2UgPSAoLi4udHJhbnNmb3JtZXJzKSA9PiB7XG4gIGNvbnN0IG51bVRyYW5zZm9ybWVycyA9IHRyYW5zZm9ybWVycy5sZW5ndGg7XG4gIGxldCBpID0gMDtcblxuICByZXR1cm4gKHYsIHZhbHVlKSA9PiB7XG4gICAgZm9yIChpID0gMDsgaSA8IG51bVRyYW5zZm9ybWVyczsgaSsrKSB7XG4gICAgICB2ID0gdHJhbnNmb3JtZXJzW2ldKHYsIHZhbHVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdjtcbiAgfTtcbn07XG5cbmV4cG9ydCBjb25zdCBpbnRlcnBvbGF0ZSA9IChpbnB1dCwgb3V0cHV0LCByYW5nZUVhc2luZykgPT4ge1xuICBjb25zdCByYW5nZUxlbmd0aCA9IGlucHV0Lmxlbmd0aDtcbiAgY29uc3QgZmluYWxJbmRleCA9IHJhbmdlTGVuZ3RoIC0gMTtcblxuICByZXR1cm4gKHYpID0+IHtcbiAgICAvLyBJZiB2YWx1ZSBvdXRzaWRlIG1pbmltdW0gcmFuZ2UsIHF1aWNrbHkgcmV0dXJuXG4gICAgaWYgKHYgPD0gaW5wdXRbMF0pIHtcbiAgICAgIHJldHVybiBvdXRwdXRbMF07XG4gICAgfVxuXG4gICAgLy8gSWYgdmFsdWUgb3V0c2lkZSBtYXhpbXVtIHJhbmdlLCBxdWlja2x5IHJldHVyblxuICAgIGlmICh2ID49IGlucHV0W2ZpbmFsSW5kZXhdKSB7XG4gICAgICByZXR1cm4gb3V0cHV0W2ZpbmFsSW5kZXhdO1xuICAgIH1cblxuICAgIGxldCBpID0gMDtcblxuICAgIC8vIEZpbmQgaW5kZXggb2YgcmFuZ2Ugc3RhcnRcbiAgICBmb3IgKDsgaSA8IHJhbmdlTGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChpbnB1dFtpXSA+IHYgfHwgaSA9PT0gZmluYWxJbmRleCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBwcm9ncmVzc0luUmFuZ2UgPSBnZXRQcm9ncmVzc0Zyb21WYWx1ZSh2LCBpbnB1dFtpXSwgaW5wdXRbaSArIDFdKTtcbiAgICBjb25zdCBlYXNlZFByb2dyZXNzID0gKHJhbmdlRWFzaW5nKSA/IHJhbmdlRWFzaW5nW2ldKHByb2dyZXNzSW5SYW5nZSkgOiBwcm9ncmVzc0luUmFuZ2U7XG4gICAgcmV0dXJuIGdldFZhbHVlRnJvbVByb2dyZXNzKGVhc2VkUHJvZ3Jlc3MsIG91dHB1dFtpXSwgb3V0cHV0W2kgKyAxXSk7XG4gIH07XG59O1xuXG4vKipcbiAqIFJlc3RyaWN0IHZhbHVlIGJldHdlZW5cbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgcmVzdHJpY3QgYSBnaXZlbiB2YWx1ZSBiZXR3ZWVuIGBtaW5gIGFuZCBgbWF4YFxuICogQHBhcmFtICB7bnVtYmVyfSBtaW5cbiAqIEBwYXJhbSAge251bWJlcn0gbWF4XG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCByZXN0cmljdFVuZGVyID0gKG1heCkgPT4gKHYpID0+IE1hdGgubWluKHYsIG1heCk7XG5leHBvcnQgY29uc3QgcmVzdHJpY3RPdmVyID0gKG1pbikgPT4gKHYpID0+IE1hdGgubWF4KHYsIG1pbik7XG5leHBvcnQgY29uc3QgcmVzdHJpY3RCZXR3ZWVuID0gKG1pbiwgbWF4KSA9PiBjb21wb3NlKHJlc3RyaWN0T3ZlcihtaW4pLCByZXN0cmljdFVuZGVyKG1heCkpO1xuXG5leHBvcnQgY29uc3Qgc3RlcHBlZE1vdGlvbiA9IChtaW4sIG1heCkgPT4gKHYpID0+IHtcbiAgXG59OyJdfQ==