'use strict';

exports.__esModule = true;
exports.steppedMotion = exports.clamp = exports.clampOver = exports.clampUnder = exports.interpolate = exports.pipe = exports.appendUnit = undefined;

var _calc = require('../inc/calc');

/**
 * Append Unit
 * Creates a function that will append the unit to a given value
 * appendUnit('px')(20) -> '20px'
 * @param  {string} unit)
 * @return {number}
 */
var appendUnit = exports.appendUnit = function (unit) {
  return function (v) {
    return '' + v + unit;
  };
};

/**
 * Pipe
 * Compose other transformers to run linearily
 * pipe(min(20), max(40))
 * @param  {...functions} transformers
 * @return {function}
 */
var pipe = exports.pipe = function () {
  for (var _len = arguments.length, transformers = Array(_len), _key = 0; _key < _len; _key++) {
    transformers[_key] = arguments[_key];
  }

  var numTransformers = transformers.length;
  var i = 0;

  return function (v, value) {
    for (i = 0; i < numTransformers; i++) {
      v = transformers[i](v, value);
    }

    return v;
  };
};

var interpolate = exports.interpolate = function (input, output, rangeEasing) {
  var rangeLength = input.length;
  var finalIndex = rangeLength - 1;

  return function (v) {
    // If value outside minimum range, quickly return
    if (v <= input[0]) {
      return output[0];
    }

    // If value outside maximum range, quickly return
    if (v >= input[finalIndex]) {
      return output[finalIndex];
    }

    var i = 0;

    // Find index of range start
    for (; i < rangeLength; i++) {
      if (input[i] > v || i === finalIndex) {
        break;
      }
    }

    var progressInRange = (0, _calc.getProgressFromValue)(v, input[i], input[i + 1]);
    var easedProgress = rangeEasing ? rangeEasing[i](progressInRange) : progressInRange;
    return (0, _calc.getValueFromProgress)(easedProgress, output[i], output[i + 1]);
  };
};

/**
 * Clamp value between
 * Creates a function that will restrict a given value between `min` and `max`
 * @param  {number} min
 * @param  {number} max
 * @return {number}
 */
var clampUnder = exports.clampUnder = function (max) {
  return function (v) {
    return Math.min(v, max);
  };
};
var clampOver = exports.clampOver = function (min) {
  return function (v) {
    return Math.max(v, min);
  };
};
var clamp = exports.clamp = function (min, max) {
  return flow(clampOver(min), clampUnder(max));
};

var steppedMotion = exports.steppedMotion = function (min, max) {
  return function (v) {};
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy92YWx1ZS9maWx0ZXJzLmpzIl0sIm5hbWVzIjpbImFwcGVuZFVuaXQiLCJ1bml0IiwidiIsInBpcGUiLCJ0cmFuc2Zvcm1lcnMiLCJudW1UcmFuc2Zvcm1lcnMiLCJsZW5ndGgiLCJpIiwidmFsdWUiLCJpbnRlcnBvbGF0ZSIsImlucHV0Iiwib3V0cHV0IiwicmFuZ2VFYXNpbmciLCJyYW5nZUxlbmd0aCIsImZpbmFsSW5kZXgiLCJwcm9ncmVzc0luUmFuZ2UiLCJlYXNlZFByb2dyZXNzIiwiY2xhbXBVbmRlciIsIm1heCIsIk1hdGgiLCJtaW4iLCJjbGFtcE92ZXIiLCJjbGFtcCIsImZsb3ciLCJzdGVwcGVkTW90aW9uIl0sIm1hcHBpbmdzIjoiOzs7OztBQUFBOztBQUVBOzs7Ozs7O0FBT08sSUFBTUEsa0NBQWEsVUFBQ0MsSUFBRDtBQUFBLFNBQVUsVUFBQ0MsQ0FBRDtBQUFBLGdCQUFVQSxDQUFWLEdBQWNELElBQWQ7QUFBQSxHQUFWO0FBQUEsQ0FBbkI7O0FBRVA7Ozs7Ozs7QUFPTyxJQUFNRSxzQkFBTyxZQUFxQjtBQUFBLG9DQUFqQkMsWUFBaUI7QUFBakJBLGdCQUFpQjtBQUFBOztBQUN2QyxNQUFNQyxrQkFBa0JELGFBQWFFLE1BQXJDO0FBQ0EsTUFBSUMsSUFBSSxDQUFSOztBQUVBLFNBQU8sVUFBQ0wsQ0FBRCxFQUFJTSxLQUFKLEVBQWM7QUFDbkIsU0FBS0QsSUFBSSxDQUFULEVBQVlBLElBQUlGLGVBQWhCLEVBQWlDRSxHQUFqQyxFQUFzQztBQUNwQ0wsVUFBSUUsYUFBYUcsQ0FBYixFQUFnQkwsQ0FBaEIsRUFBbUJNLEtBQW5CLENBQUo7QUFDRDs7QUFFRCxXQUFPTixDQUFQO0FBQ0QsR0FORDtBQU9ELENBWE07O0FBYUEsSUFBTU8sb0NBQWMsVUFBQ0MsS0FBRCxFQUFRQyxNQUFSLEVBQWdCQyxXQUFoQixFQUFnQztBQUN6RCxNQUFNQyxjQUFjSCxNQUFNSixNQUExQjtBQUNBLE1BQU1RLGFBQWFELGNBQWMsQ0FBakM7O0FBRUEsU0FBTyxVQUFDWCxDQUFELEVBQU87QUFDWjtBQUNBLFFBQUlBLEtBQUtRLE1BQU0sQ0FBTixDQUFULEVBQW1CO0FBQ2pCLGFBQU9DLE9BQU8sQ0FBUCxDQUFQO0FBQ0Q7O0FBRUQ7QUFDQSxRQUFJVCxLQUFLUSxNQUFNSSxVQUFOLENBQVQsRUFBNEI7QUFDMUIsYUFBT0gsT0FBT0csVUFBUCxDQUFQO0FBQ0Q7O0FBRUQsUUFBSVAsSUFBSSxDQUFSOztBQUVBO0FBQ0EsV0FBT0EsSUFBSU0sV0FBWCxFQUF3Qk4sR0FBeEIsRUFBNkI7QUFDM0IsVUFBSUcsTUFBTUgsQ0FBTixJQUFXTCxDQUFYLElBQWdCSyxNQUFNTyxVQUExQixFQUFzQztBQUNwQztBQUNEO0FBQ0Y7O0FBRUQsUUFBTUMsa0JBQWtCLGdDQUFxQmIsQ0FBckIsRUFBd0JRLE1BQU1ILENBQU4sQ0FBeEIsRUFBa0NHLE1BQU1ILElBQUksQ0FBVixDQUFsQyxDQUF4QjtBQUNBLFFBQU1TLGdCQUFpQkosV0FBRCxHQUFnQkEsWUFBWUwsQ0FBWixFQUFlUSxlQUFmLENBQWhCLEdBQWtEQSxlQUF4RTtBQUNBLFdBQU8sZ0NBQXFCQyxhQUFyQixFQUFvQ0wsT0FBT0osQ0FBUCxDQUFwQyxFQUErQ0ksT0FBT0osSUFBSSxDQUFYLENBQS9DLENBQVA7QUFDRCxHQXZCRDtBQXdCRCxDQTVCTTs7QUE4QlA7Ozs7Ozs7QUFPTyxJQUFNVSxrQ0FBYSxVQUFDQyxHQUFEO0FBQUEsU0FBUyxVQUFDaEIsQ0FBRDtBQUFBLFdBQU9pQixLQUFLQyxHQUFMLENBQVNsQixDQUFULEVBQVlnQixHQUFaLENBQVA7QUFBQSxHQUFUO0FBQUEsQ0FBbkI7QUFDQSxJQUFNRyxnQ0FBWSxVQUFDRCxHQUFEO0FBQUEsU0FBUyxVQUFDbEIsQ0FBRDtBQUFBLFdBQU9pQixLQUFLRCxHQUFMLENBQVNoQixDQUFULEVBQVlrQixHQUFaLENBQVA7QUFBQSxHQUFUO0FBQUEsQ0FBbEI7QUFDQSxJQUFNRSx3QkFBUSxVQUFDRixHQUFELEVBQU1GLEdBQU47QUFBQSxTQUFjSyxLQUFLRixVQUFVRCxHQUFWLENBQUwsRUFBcUJILFdBQVdDLEdBQVgsQ0FBckIsQ0FBZDtBQUFBLENBQWQ7O0FBRUEsSUFBTU0sd0NBQWdCLFVBQUNKLEdBQUQsRUFBTUYsR0FBTjtBQUFBLFNBQWMsVUFBQ2hCLENBQUQsRUFBTyxDQUVqRCxDQUY0QjtBQUFBLENBQXRCIiwiZmlsZSI6ImZpbHRlcnMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnZXRQcm9ncmVzc0Zyb21WYWx1ZSwgZ2V0VmFsdWVGcm9tUHJvZ3Jlc3MgfSBmcm9tICcuLi9pbmMvY2FsYyc7XG5cbi8qKlxuICogQXBwZW5kIFVuaXRcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgYXBwZW5kIHRoZSB1bml0IHRvIGEgZ2l2ZW4gdmFsdWVcbiAqIGFwcGVuZFVuaXQoJ3B4JykoMjApIC0+ICcyMHB4J1xuICogQHBhcmFtICB7c3RyaW5nfSB1bml0KVxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgYXBwZW5kVW5pdCA9ICh1bml0KSA9PiAodikgPT4gYCR7dn0ke3VuaXR9YDtcblxuLyoqXG4gKiBQaXBlXG4gKiBDb21wb3NlIG90aGVyIHRyYW5zZm9ybWVycyB0byBydW4gbGluZWFyaWx5XG4gKiBwaXBlKG1pbigyMCksIG1heCg0MCkpXG4gKiBAcGFyYW0gIHsuLi5mdW5jdGlvbnN9IHRyYW5zZm9ybWVyc1xuICogQHJldHVybiB7ZnVuY3Rpb259XG4gKi9cbmV4cG9ydCBjb25zdCBwaXBlID0gKC4uLnRyYW5zZm9ybWVycykgPT4ge1xuICBjb25zdCBudW1UcmFuc2Zvcm1lcnMgPSB0cmFuc2Zvcm1lcnMubGVuZ3RoO1xuICBsZXQgaSA9IDA7XG5cbiAgcmV0dXJuICh2LCB2YWx1ZSkgPT4ge1xuICAgIGZvciAoaSA9IDA7IGkgPCBudW1UcmFuc2Zvcm1lcnM7IGkrKykge1xuICAgICAgdiA9IHRyYW5zZm9ybWVyc1tpXSh2LCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHY7XG4gIH07XG59O1xuXG5leHBvcnQgY29uc3QgaW50ZXJwb2xhdGUgPSAoaW5wdXQsIG91dHB1dCwgcmFuZ2VFYXNpbmcpID0+IHtcbiAgY29uc3QgcmFuZ2VMZW5ndGggPSBpbnB1dC5sZW5ndGg7XG4gIGNvbnN0IGZpbmFsSW5kZXggPSByYW5nZUxlbmd0aCAtIDE7XG5cbiAgcmV0dXJuICh2KSA9PiB7XG4gICAgLy8gSWYgdmFsdWUgb3V0c2lkZSBtaW5pbXVtIHJhbmdlLCBxdWlja2x5IHJldHVyblxuICAgIGlmICh2IDw9IGlucHV0WzBdKSB7XG4gICAgICByZXR1cm4gb3V0cHV0WzBdO1xuICAgIH1cblxuICAgIC8vIElmIHZhbHVlIG91dHNpZGUgbWF4aW11bSByYW5nZSwgcXVpY2tseSByZXR1cm5cbiAgICBpZiAodiA+PSBpbnB1dFtmaW5hbEluZGV4XSkge1xuICAgICAgcmV0dXJuIG91dHB1dFtmaW5hbEluZGV4XTtcbiAgICB9XG5cbiAgICBsZXQgaSA9IDA7XG5cbiAgICAvLyBGaW5kIGluZGV4IG9mIHJhbmdlIHN0YXJ0XG4gICAgZm9yICg7IGkgPCByYW5nZUxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoaW5wdXRbaV0gPiB2IHx8IGkgPT09IGZpbmFsSW5kZXgpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgcHJvZ3Jlc3NJblJhbmdlID0gZ2V0UHJvZ3Jlc3NGcm9tVmFsdWUodiwgaW5wdXRbaV0sIGlucHV0W2kgKyAxXSk7XG4gICAgY29uc3QgZWFzZWRQcm9ncmVzcyA9IChyYW5nZUVhc2luZykgPyByYW5nZUVhc2luZ1tpXShwcm9ncmVzc0luUmFuZ2UpIDogcHJvZ3Jlc3NJblJhbmdlO1xuICAgIHJldHVybiBnZXRWYWx1ZUZyb21Qcm9ncmVzcyhlYXNlZFByb2dyZXNzLCBvdXRwdXRbaV0sIG91dHB1dFtpICsgMV0pO1xuICB9O1xufTtcblxuLyoqXG4gKiBDbGFtcCB2YWx1ZSBiZXR3ZWVuXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCB3aWxsIHJlc3RyaWN0IGEgZ2l2ZW4gdmFsdWUgYmV0d2VlbiBgbWluYCBhbmQgYG1heGBcbiAqIEBwYXJhbSAge251bWJlcn0gbWluXG4gKiBAcGFyYW0gIHtudW1iZXJ9IG1heFxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgY2xhbXBVbmRlciA9IChtYXgpID0+ICh2KSA9PiBNYXRoLm1pbih2LCBtYXgpO1xuZXhwb3J0IGNvbnN0IGNsYW1wT3ZlciA9IChtaW4pID0+ICh2KSA9PiBNYXRoLm1heCh2LCBtaW4pO1xuZXhwb3J0IGNvbnN0IGNsYW1wID0gKG1pbiwgbWF4KSA9PiBmbG93KGNsYW1wT3ZlcihtaW4pLCBjbGFtcFVuZGVyKG1heCkpO1xuXG5leHBvcnQgY29uc3Qgc3RlcHBlZE1vdGlvbiA9IChtaW4sIG1heCkgPT4gKHYpID0+IHtcbiAgXG59OyJdfQ==